local runservice = game:GetService("RunService")
local camera = workspace.CurrentCamera
local players = game:GetService("Players")
local replicatedStorage = game:GetService("ReplicatedStorage")
local localplayer = players.LocalPlayer
local inputservice = game:GetService("UserInputService")
local mouse = localplayer:GetMouse()
local SoundService = game:GetService("SoundService")
local Stats = game:GetService("Stats")
local Player = game:GetService("Players").LocalPlayer

-- // FIX UI (REQUIRED)
getgenv().triggerbot = getgenv().triggerbot or {
    Enabled = false,
    TriggerCooldown = 0.01,
    BlacklistedTools = {},
}

getgenv().stile = {
    hitbox_expander = {
        Enabled = false,
        Size = 15,
        Transparency = 0.5,
        Color = Color3.fromRGB(255, 0, 0),
    },

    Visuals = {
        Self = {
            Enabled = false,
            Color = Color3.fromRGB(255, 255, 255),
        }
    }
}

local MacroEnabled = false
local EmoteEnabled = false
local EmoteID = "15610015346" -- YungBlud Emote

local repo = 'https://raw.githubusercontent.com/VardySc/Pornhub/main/'
local library = loadstring(game:HttpGet('https://raw.githubusercontent.com/VardySc/Pornhub/main/Library.lua'))()
local thememanager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local savemanager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

Library:SetWatermarkVisibility(true)

local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter += 1

    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end

    local currentTime = os.date("%H:%M:%S")

    Library:SetWatermark(('Eclipse.lol| %s fps | %s ms | Time: %s'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue()),
        currentTime
    ))
end)

local ToggleGui = Instance.new("ScreenGui")
ToggleGui.Name = "UIToggle"
ToggleGui.ResetOnSpawn = false
ToggleGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ToggleGui.Parent = game.CoreGui

local ToggleButton = Instance.new("ImageButton")
ToggleButton.Size = UDim2.new(0, 70, 0, 50)
ToggleButton.Position = UDim2.new(1, -110, 0, 10)
ToggleButton.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
ToggleButton.BackgroundTransparency = 1
ToggleButton.Image = "rbxassetid://109014824057194"
ToggleButton.Parent = ToggleGui

Instance.new("UICorner", ToggleButton).CornerRadius = UDim.new(0, 10)

local isVisible = true
ToggleButton.MouseButton1Click:Connect(function()
    if library and library.Toggle then
        library:Toggle()
        isVisible = not isVisible
        -- same image both states as you chose Option 1
        ToggleButton.Image = "rbxassetid://109014824057194"
    end
end)

local game_name = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name

local Hooks = {}

getgenv().Divine = {
  Settings = {
    Smoothness = 0.1,
  },

  Camlock = {
    enabled = true,
    resolver = false,
    HorizontalPrediction = 0.1,
    VerticalPrediction = 0.1,
    HitPart = "HumanoidRootPart",
    target = nil
  },

  Targetaim = {
    enabled = true,
    target = nil,
    predictionEnabled = true,
    HorizontalPrediction = 0.1,
    VerticalPrediction = 0.1,
    HitPart = "HumanoidRootPart",
    Method = "Namecall"
  },

  AutoAir = {
   enabled = true,
   jumpOffset = -0.20,
   fallOffset = 0.15, -- NEW (Psalm style)
   delay = 0.22,
   AirPart = "RightFoot"
}
}

getgenv().crosshair = {
    enabled = false,
    refreshrate = 0,
    mode = "center",
    position = Vector2.new(0, 0),
    width = 1.5,
    length = 10,
    radius = 11,
    color = Color3.fromRGB(255, 255, 255),
    spin = true,
    spin_speed = 120,
    spin_max = 200,
    spin_style = Enum.EasingStyle.Circular,
    resize = true,
    resize_speed = 150,
    resize_min = 5,
    resize_max = 22
}

local Window = library:CreateWindow({
    Title = 'Eclipse',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2,
    Footer = "1.0.0 Eclipse REWRITE",
    Size = UDim2.fromOffset(620, 500),
    Icon = "rbxasset://132866879342416"
})

local Options = library.Options

local Tabs = {
    combat = Window:AddTab("Combat", "crosshair"),
	 raging = Window:AddTab("Rage", "eye"),
    visuals = Window:AddTab("Miscellaneous ", "wrench"),
    Settings = Window:AddTab("Settings", "settings")
}


local Divine = getgenv().Divine

local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")
local SoundService = game:GetService("SoundService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Camera = workspace.CurrentCamera

local function FindNearestEnemy()
  local closest = nil
	local shortestDist = math.huge
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
			local pos = plr.Character.HumanoidRootPart.Position
			local screenPos, onScreen = Camera:WorldToViewportPoint(pos)
			if onScreen then
				local dist = (Vector2.new(screenPos.X, screenPos.Y) - Camera.ViewportSize / 2).Magnitude
				if dist < shortestDist then
					shortestDist = dist
					closest = plr
				end
			end
		end
	end
	return closest
end

-- MANUAL LOCK ONLY â€” NO AUTO LOCK AT ALL
task.spawn(function()
    while task.wait(0.05) do
        local divine = getgenv().Divine
        if not divine then continue end

        -- Validate TargetAim target
        if divine.Targetaim.target then
            local t = divine.Targetaim.target
            local valid =
                t and t.Character and
                t.Character:FindFirstChild(divine.Targetaim.HitPart) and
                t.Character:FindFirstChildOfClass("Humanoid") and
                t.Character.Humanoid.Health > 0

            if not valid then
                -- DO NOT auto-lock a new target
                divine.Targetaim.target = nil
            end
        end

        -- Validate Camlock target
        if divine.Camlock.target then
            local t = divine.Camlock.target
            local valid =
                t and t.Character and
                t.Character:FindFirstChild(divine.Camlock.HitPart) and
                t.Character:FindFirstChildOfClass("Humanoid") and
                t.Character.Humanoid.Health > 0

            if not valid then
                -- DO NOT auto-lock a new target
                divine.Camlock.target = nil
            end
        end
    end
end)

local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local TextButton = Instance.new("ImageButton")
local UICorner = Instance.new("UICorner")

local CoreGui = game:GetService("CoreGui")
ScreenGui.Parent = CoreGui
ScreenGui.ResetOnSpawn = false
ScreenGui.Enabled = true

Frame.Parent = ScreenGui
Frame.BackgroundTransparency = 1
Frame.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame.Size = UDim2.new(0, 90, 0, 90)
Frame.Active = true

TextButton.Parent = Frame
TextButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
TextButton.BackgroundTransparency = 0.5
TextButton.Size = UDim2.new(0, 75, 0, 75)
TextButton.AnchorPoint = Vector2.new(0.5, 0.5)
TextButton.Position = UDim2.new(0.5, 0, 0.5, 0)
TextButton.Image = "rbxassetid://71218955901149"
TextButton.Active = true

local Outline = Instance.new("UIStroke")
Outline.Color = Color3.fromRGB(255, 255, 255)
Outline.Thickness = 1
Outline.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
Outline.Parent = TextButton

TextButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = TextButton.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

TextButton.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        TextButton.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
    end
end)

UICorner.Parent = TextButton
UICorner.CornerRadius = UDim.new(0, 12)

TextButton.MouseButton1Click:Connect(function()
    getgenv().Divine.Camlock.enabled = not getgenv().Divine.Camlock.enabled

    if getgenv().Divine.Camlock.enabled then
        local enemy = FindNearestEnemy()
        if enemy then
            getgenv().Divine.Camlock.target = enemy
            getgenv().Divine.Targetaim.target = enemy
            TextButton.Image = "rbxassetid://71218955901149"
            library:Notify("EC: Enabled, Target: " .. enemy.DisplayName, 2)
        else
            getgenv().Divine.Camlock.enabled = false
            getgenv().Divine.Targetaim.enabled = false
            TextButton.Image = "rbxassetid://71218955901149"
            library:Notify("No Target Found", 2)
        end
    else
        getgenv().Divine.Camlock.target = nil
        getgenv().Divine.Targetaim.target = nil
        TextButton.Image = "rbxassetid://71218955901149"
        library:Notify("EC: Spared Target", 2)
    end
end)

local UserInputService = game:GetService("UserInputService")

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end

    -------------------------------
    --  F KEY (Keyboard Toggle)
    -------------------------------
    if input.KeyCode == Enum.KeyCode.F then
        
        getgenv().Divine.Camlock.enabled = not getgenv().Divine.Camlock.enabled

        if getgenv().Divine.Camlock.enabled then
            local enemy = FindNearestEnemy()
            if enemy then
                getgenv().Divine.Camlock.target = enemy
                getgenv().Divine.Targetaim.target = enemy
                TextButton.Image = "rbxassetid://71218955901149"
                library:Notify("EC: Enabled (F), Target: " .. enemy.DisplayName, 2)
            end
        else
            getgenv().Divine.Camlock.target = nil
            getgenv().Divine.Targetaim.target = nil
            TextButton.Image = "rbxassetid://71218955901149"
            library:Notify("EC: Disabled (F)", 2)
        end
    end


    -------------------------------
    --  CONTROLLER BUTTON Y
    -------------------------------
    if input.KeyCode == Enum.KeyCode.ButtonY then
        
        getgenv().Divine.Camlock.enabled = not getgenv().Divine.Camlock.enabled

        if getgenv().Divine.Camlock.enabled then
            local enemy = FindNearestEnemy()
            if enemy then
                getgenv().Divine.Camlock.target = enemy
                getgenv().Divine.Targetaim.target = enemy
                TextButton.Image = "rbxassetid://71218955901149"
                library:Notify("EC: Enabled (Y), Target: " .. enemy.DisplayName, 2)
            end
        else
            getgenv().Divine.Camlock.target = nil
            getgenv().Divine.Targetaim.target = nil
            TextButton.Image = "rbxassetid://71218955901149"
            library:Notify("EC: Disabled (Y)", 2)
        end
    end
end)

RunService.Heartbeat:Connect(function()
    if Divine.Camlock.enabled then
        local camTarget = Divine.Camlock.target
        if camTarget and camTarget.Character then
            local camPart = camTarget.Character:FindFirstChild(Divine.Camlock.HitPart)
            if camPart then
                local camPredicted = camPart.Position
    + Vector3.new(
        camPart.Velocity.X * Divine.Camlock.HorizontalPrediction,
        camPart.Velocity.Y * Divine.Camlock.VerticalPrediction,
        camPart.Velocity.Z * Divine.Camlock.HorizontalPrediction
    )

                local camGoal = CFrame.new(Camera.CFrame.Position, camPredicted)
                Camera.CFrame = Camera.CFrame:Lerp(camGoal, Divine.Settings.Smoothness)
            end
        end
    end

    if Divine.AutoAir.enabled then
        local Victim = Divine.Targetaim.target
        if Victim and Victim.Character then
            local TargetRootPart = Victim.Character:FindFirstChild(Divine.AutoAir.AirPart)
            if TargetRootPart then
                local TargetVel = TargetRootPart.Velocity
                if TargetVel.Y > 25 then
                    local Character = LocalPlayer.Character
                    if Character then
                        local Tool = Character:FindFirstChildOfClass("Tool")
                        if Tool then
                            task.wait(Divine.AutoAir.delay)
                            Tool:Activate()
                        end
                    end
                end
            end
        end
    end
end)

if not Divine.Camlock.enabled and Divine.AutoAir.enabled then return end

if Divine.Targetaim.Method == "Namecall" then
    local __namecall
    __namecall = hookmetamethod(game, "__namecall", newcclosure(function(Self, ...)
        local Args = {...}
        local Method = tostring(getnamecallmethod())
        if not checkcaller() and Method == "FireServer" then
            for i, Arg in pairs(Args) do
                if typeof(Arg) == "Vector3" and Divine.Targetaim.enabled then
                    local Target = Divine.Targetaim.target
                    if Target and Target.Character and Divine.Targetaim.HitPart and Target.Character[Divine.Targetaim.HitPart] then
                        local TargetPart = Target.Character[Divine.Targetaim.HitPart]
                        local offset = Divine.AutoAir and Divine.AutoAir.jumpOffset or 0
                        local predictedPosition = TargetPart.Position
                            + Vector3.new(
    TargetPart.Velocity.X * Divine.Targetaim.HorizontalPrediction,
    TargetPart.Velocity.Y * Divine.Targetaim.VerticalPrediction,
    TargetPart.Velocity.Z * Divine.Targetaim.HorizontalPrediction
)
                            + Vector3.new(0, Divine.AutoAir.jumpOffset, 0)

                        Args[i] = predictedPosition
                    end
                    return __namecall(Self, unpack(Args))
                end
            end
        end
        return __namecall(Self, ...)
    end))
end

local function setup_hooks()
    local function TargetFuturePosition()
        if not target or not target.Character then
            return nil
        end
        local target_part = target.Character[Divine.Targetaim.HitPart]
        if not target_part then
            return nil
        end

        local position = target_part.Position
        if Divine.Targetaim.predictionEnabled then
            position = position + (target_part.Velocity * Divine.Targetaim.Prediction) local Yoffset = 0

-- Psalm logic (Up = JumpOffset, Down = FallOffset)
if TargetPart.Velocity.Y > 1 then
    Yoffset = Divine.AutoAir.jumpOffset
elseif TargetPart.Velocity.Y < -1 then
    Yoffset = Divine.AutoAir.fallOffset
end

Args[i] = predictedPosition + Vector3.new(0, Yoffset, 0)
        end
        return position
    end

    Hooks[1] =
        hookmetamethod(
        mouse,
        "__index",
        newcclosure(
            function(self, index)
                if
                    index == "Hit" and locking and (Divine.Targetaim.Method == "Index") and
                        target and
                        target.Character and
                        target.Character:FindFirstChild(Divine.Targetaim.HitPart)
                 then
                    local futurePos = TargetFuturePosition()
                    if futurePos then
                        return CFrame.new(futurePos)
                    end
                end
                return Hooks[1](self, index)
            end
        )
    )
end

if not Divine.Targetaim.enabled then return end

local function onHeartbeat()
    if not getgenv().Divine.Camlock.resolver then return end

    for _, Target in pairs(Players:GetPlayers()) do
        if Target ~= LocalPlayer and Target.Character then
            local Character = Target.Character
            local Humanoid = Character:FindFirstChildOfClass("Humanoid")

            if Humanoid and Humanoid.MoveDirection.Magnitude > 0 then
                local moveVelocity = Humanoid.MoveDirection * 16

                local TargetParts = {
                    "HumanoidRootPart",
                    "UpperTorso",
                    "LowerTorso",
                    "LeftUpperLeg",
                    "LeftLowerLeg",
                    "RightUpperLeg",
                    "RightLowerLeg",
                    "Head",
                    "LeftHand",
                    "RightHand"
                }

                for _, partName in ipairs(TargetParts) do
                    local Part = Character:FindFirstChild(partName)
                    if Part then
                        Part.Velocity = moveVelocity
                        Part.AssemblyLinearVelocity = moveVelocity
                    end
                end
            end
        end
    end
end

RunService.Heartbeat:Connect(onHeartbeat)

getgenv().cframe = getgenv().cframe or {}
local cframe = getgenv().cframe

cframe.settings = {
    enabled = true,
    showbutton = true,
    speed = 1
}

local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")

if cframe.settings.showbutton then
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "SpeedCFrameGUI"
    ScreenGui.ResetOnSpawn = false
    ScreenGui.Parent = game.CoreGui

    local Button = Instance.new("TextButton")
    Button.Name = "SpeedCFrameButton"
    Button.Size = UDim2.new(0, 80, 0, 60)
    Button.Position = UDim2.new(0.55, -955, 0.57, -355)
    Button.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Button.BackgroundTransparency = 0.1
    Button.Text = cframe.settings.enabled and "CF: ON" or "CF: OFF"
    Button.TextColor3 = Color3.fromRGB(255, 255, 255)
    Button.Font = Enum.Font.Code
    Button.TextSize = 18
    Button.Parent = ScreenGui

    local Outline = Instance.new("UIStroke")
    Outline.Color = Color3.fromRGB(250, 250, 250)
    Outline.Thickness = 1
    Outline.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    Outline.Parent = Button

    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 10)
    UICorner.Parent = Button

    Button.MouseButton1Click:Connect(function()
        cframe.settings.enabled = not cframe.settings.enabled
        Button.Text = cframe.settings.enabled and "CF: ON" or "CF: OFF"
    end)

    -- Dragging support
    local dragging = false
    local startPos, startMousePos

    Button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            startPos = Button.Position
            startMousePos = input.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    Button.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - startMousePos
            Button.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y
            )
        end
    end)
end

if not getgenv().cframe.settings.showbutton then return end

RunService.Heartbeat:Connect(function()
    if cframe.settings.enabled and LocalPlayer.Character then
        local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if root and humanoid then
            local move_dir = humanoid.MoveDirection
            root.CFrame = root.CFrame + (move_dir * cframe.settings.speed)
        end
    end
end)

--// AUTO PREDICTION (DaStrike Blatant)

local function getPing()
    return game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
end

local autoPredictionRunning = false

local function startAutoPrediction()
    if autoPredictionRunning then return end
    autoPredictionRunning = true

    task.spawn(function()
        while autoPredictionRunning do

            local ping = getPing()
            local pred

            if ping <= 40 then
                pred = 0.1458912       -- 40ms Blatant
            elseif ping <= 50 then
                pred = 0.1403592       -- 50ms Blatant
            elseif ping <= 60 then
                pred = 0.1213536       -- 60ms Blatant
            elseif ping <= 70 then
                pred = 0.1355798        -- 70ms Blatant
            elseif ping <= 80 then
                pred = 0.1226346       -- 80ms Blatant
            elseif ping <= 90 then
                pred = 0.1400822       -- 90ms Blatant
            elseif ping <= 100 then
                pred = 0.1436029425      -- 100ms Blatant
            elseif ping <= 120 then
                pred = 0.1155657825
            elseif ping <= 140 then
                pred = 0.1491826658
            else
                pred = 0.1404715572
            end

           getgenv().Divine.Targetaim.HorizontalPrediction = pred
getgenv().Divine.Targetaim.VerticalPrediction = pred

getgenv().Divine.Camlock.HorizontalPrediction = pred
getgenv().Divine.Camlock.VerticalPrediction = pred

            task.wait(1)
        end
    end)
end

local function stopAutoPrediction()
    autoPredictionRunning = false
end
local function stopAutoPrediction()
	autoPredictionRunning = false
end

getgenv().exlareCircle = getgenv().exlareCircle or {
	enabled = false,
	color = Color3.fromRGB(255, 255, 255),
	radius = 100,
	circle = nil
}

if not getgenv().exlareCircle.circle then
	getgenv().exlareCircle.circle = Drawing.new("Circle")
	getgenv().exlareCircle.circle.Filled = false
	getgenv().exlareCircle.circle.Thickness = 1
end

function updateexlareCircle()
	if getgenv().exlareCircle.circle then
		getgenv().exlareCircle.circle.Visible = getgenv().exlareCircle.enabled
		getgenv().exlareCircle.circle.Color = getgenv().exlareCircle.color
		getgenv().exlareCircle.circle.Radius = getgenv().exlareCircle.radius
		getgenv().exlareCircle.circle.Position = Vector2.new(
			workspace.CurrentCamera.ViewportSize.X / 2,
			workspace.CurrentCamera.ViewportSize.Y / 2
		)
	end
end

game:GetService("RunService").RenderStepped:Connect(function()
	if getgenv().exlareCircle.enabled and getgenv().exlareCircle.circle then
		getgenv().exlareCircle.circle.Position = Vector2.new(
			workspace.CurrentCamera.ViewportSize.X / 2,
			workspace.CurrentCamera.ViewportSize.Y / 2
		)
	end
end)

local old
old =
    hookfunction(
    Drawing.new,
    function(class, properties)
        local drawing = old(class)
        for i, v in next, properties or {} do
            drawing[i] = v
        end
        return drawing
    end
)

local function solve(angle, radius)
    return Vector2.new(math.sin(math.rad(angle)) * radius, math.cos(math.rad(angle)) * radius)
end

local last_render = 0
local drawings = {
    crosshair = {},
    text = {
        Drawing.new("Text", {Size = 13, Font = 2, Outline = true, Text = "Eclipse", Color = Color3.new(1, 1, 1)}),
        Drawing.new("Text", {Size = 13, Font = 2, Outline = true, Text = " .lol", Color = Color3.new(0.5, 0.5, 0.5)})
    }
}

for idx = 1, 4 do
    drawings.crosshair[idx] = Drawing.new("Line")
    drawings.crosshair[idx + 4] = Drawing.new("Line")
end

local box = Drawing.new("Square")
box.Visible = false
box.Color = Color3.new(1, 1, 1)
box.Thickness = 1
box.Filled = false

local tracer = Drawing.new("Line")
tracer.Visible = false
tracer.Color = Color3.new(1, 1, 1)
tracer.Thickness = 1

getgenv().exlare = getgenv().exlare or {}
getgenv().exlare.esp = {
	box = false,
	tracer = false
}

RunService.RenderStepped:Connect(function()
	local target = getgenv().Divine and getgenv().Divine.Targetaim and getgenv().Divine.Targetaim.target

	if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") and target.Character:FindFirstChild("Head") then
		local hrp = target.Character.HumanoidRootPart
		local head = target.Character.Head

		local hrpPos, hrpOnScreen = Camera:WorldToViewportPoint(hrp.Position)
		local headPos, headOnScreen = Camera:WorldToViewportPoint(head.Position)

		local screenHeight = math.abs(hrpPos.Y - headPos.Y) * 2
		local boxSize = Vector2.new(screenHeight / 1.5, screenHeight)

		if getgenv().exlare.esp.box and hrpOnScreen then
			box.Size = boxSize
			box.Position = Vector2.new(hrpPos.X - boxSize.X / 2, hrpPos.Y - boxSize.Y / 2)
			box.Visible = true
		else
			box.Visible = false
		end

		if getgenv().exlare.esp.tracer and hrpOnScreen then
			tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
			tracer.To = Vector2.new(hrpPos.X, hrpPos.Y)
			tracer.Visible = true
		else
			tracer.Visible = false
		end
	else
		box.Visible = false
		tracer.Visible = false
	end
end)

getgenv().hit = {
    detection = true,
    logs = true,
    notify_duration = 1,
    sound_enabled = true,
    sound_id = "Neverlose",
    sound_volume = 1
}

local HitSoundId = {
    Bameware = "rbxassetid://3124331820",
    Neverlose = "rbxassetid://6534948092",
    Bell = "rbxassetid://6534947240",
    Bubble = "rbxassetid://6534947588",
    Pick = "rbxassetid://1347140027",
    Pop = "rbxassetid://198598793",
    Rust = "rbxassetid://1255040462",
    Sans = "rbxassetid://3188795283",
    Fart = "rbxassetid://130833677",
    Big = "rbxassetid://5332005053",
    Vine = "rbxassetid://5332680810",
    Bruh = "rbxassetid://4578740568",
    Skeet = "rbxassetid://5633695679",
    Fatality = "rbxassetid://6534947869",
    Bonk = "rbxassetid://5766898159",
    Minecraft = "rbxassetid://4018616850"
}

local hitSoundsNames = {"Bameware", "Neverlose", "Bubble", "Pick", "Pop", "Rust", "Sans", "Fart", "Big", "Vine", "Bruh", "Skeet", "Fatality", "Bonk","Minecraft"}

local last_health = {}

RunService.PostSimulation:Connect(function()
    local Divine = getgenv().Divine
    if not Divine then return end

    local target = Divine.Targetaim and Divine.Targetaim.target
    local locking = Divine.Camlock and Divine.Camlock.enabled
    local humanoid = target and target.Character and target.Character:FindFirstChild("Humanoid")

    if locking and target and humanoid and hit.detection then
        local current_health = humanoid.Health

        if not last_health[target.UserId] then
            last_health[target.UserId] = current_health
        end

        if current_health < last_health[target.UserId] then
            if hit.sound_enabled and HitSoundId[hit.sound_id] then
                local sound = Instance.new("Sound")
                sound.SoundId = HitSoundId[hit.sound_id]
                sound.Volume = hit.sound_volume
                sound.Parent = workspace
                sound:Play()
                game:GetService("Debris"):AddItem(sound, 2)
            end

            if hit.logs and library then
                library:Notify("Hit: " .. target.DisplayName, hit.notify_duration)
            end
        end

        last_health[target.UserId] = current_health
    end
end)

getgenv().orbit = {
	enabled = false,
	distance = 10,
	height = 5,
	speed = 400,
	angle = 0
}

game:GetService("RunService").Heartbeat:Connect(function(dt)
	if not getgenv().orbit.enabled then return end

	local lp = game.Players.LocalPlayer
	if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then return end

	local target = getgenv().Divine and getgenv().Divine.Camlock and getgenv().Divine.Camlock.target
	if not target or not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then return end

	local root = lp.Character.HumanoidRootPart
	local targetRoot = target.Character.HumanoidRootPart

	getgenv().orbit.angle += dt * getgenv().orbit.speed
	local angleRad = math.rad(getgenv().orbit.angle)

	local offset = Vector3.new(
		math.cos(angleRad) * getgenv().orbit.distance,
		getgenv().orbit.height,
		math.sin(angleRad) * getgenv().orbit.distance
	)

	local orbitPosition = targetRoot.Position + offset
	root.CFrame = CFrame.new(orbitPosition, targetRoot.Position)
end)

getgenv().Divine.Visualize = getgenv().Divine.Visualize or {enabled = false}

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local highlight = Instance.new("Highlight")
highlight.FillColor = Color3.fromRGB(10, 10, 10)
highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
highlight.FillTransparency = 0.4
highlight.OutlineTransparency = 0
highlight.Enabled = false
highlight.Parent = game:GetService("CoreGui")

local dot = Drawing.new("Circle")
dot.Color = Color3.fromRGB(250, 250, 250)
dot.Thickness = 2
dot.Filled = true
dot.Radius = 4
dot.Visible = false

RunService.RenderStepped:Connect(function()
    if not getgenv().Divine.Visualize.enabled then
        highlight.Enabled = false
        dot.Visible = false
        return
    end

    local target = getgenv().Divine.Targetaim and getgenv().Divine.Targetaim.target
    if target and target.Character then
        local hrp = target.Character:FindFirstChild("HumanoidRootPart")

        highlight.Adornee = target.Character
        highlight.Enabled = true

        if hrp then
            local pos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(hrp.Position)
            dot.Visible = onScreen
            if onScreen then
                dot.Position = Vector2.new(pos.X, pos.Y)
            end
        end
    else
        highlight.Enabled = false
        dot.Visible = false
    end
end)

getgenv().AntiAimViewer = {
    enabled = false,
}

local China = setmetatable({}, {
    __index = function(_, service)
        return game:GetService(service)
    end
})

local Players = China.Players
local ReplicatedStorage = China.ReplicatedStorage
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local MainEvent = ReplicatedStorage:FindFirstChild("MainEvent")

local function Bypass(Entity)
    Entity.ChildAdded:Connect(function(Child)
        if Child:IsA("Tool") then
            Child.Activated:Connect(function()
                if MainEvent then
                    MainEvent:FireServer("UpdateMousePos", Mouse.Hit.Position)
                end
            end)
        end
    end)
end

local function Alive(Player)
    return Player and Player.Character and Player.Character:FindFirstChild("Humanoid") and Player.Character:FindFirstChild("Head")
end

LocalPlayer.CharacterAdded:Connect(function(Character)
    Bypass(Character)
end)

if getgenv().AntiAimViewer then
    if Alive(LocalPlayer) then
        LocalPlayer.Character.Humanoid:UnequipTools()
        Bypass(LocalPlayer.Character)
    end
end

local Hook
Hook = hookmetamethod(game, "__namecall", function(self, ...)
    local Args = {...}
    local Method = getnamecallmethod()

    if not checkcaller() and Method == "FireServer" and self.Name == "MainEvent" and Args[1] == "UpdateMousePos" then
        if getgenv().AntiAimViewer then
            Args[2] = Mouse.Hit.Position
        end
        return self.FireServer(self, unpack(Args))
    end

    return Hook(self, ...)
end)

getgenv().EnemyStats = {
    Enabled = false,
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local ScreenGui
local Frame, PFPImage, NameLabel, HealthFill

local function createGUI()
    if ScreenGui then return end

    ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Parent = game.CoreGui

    Frame = Instance.new("Frame")
    Frame.Size = UDim2.new(0, 250, 0, 100)
    Frame.AnchorPoint = Vector2.new(0.5, 0.5)
    Frame.Position = UDim2.new(0.5, 0, 0.85, 0)
    Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Frame.BorderSizePixel = 2
    Frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    Frame.Parent = ScreenGui

    PFPImage = Instance.new("ImageLabel")
    PFPImage.Size = UDim2.new(0, 80, 0, 80)
    PFPImage.Position = UDim2.new(0, 10, 0, 10)
    PFPImage.BackgroundTransparency = 1
    PFPImage.Parent = Frame

    NameLabel = Instance.new("TextLabel")
    NameLabel.Size = UDim2.new(0, 140, 0, 30)
    NameLabel.Position = UDim2.new(0, 100, 0, 10)
    NameLabel.BackgroundTransparency = 1
    NameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    NameLabel.TextScaled = true
    NameLabel.Font = Enum.Font.GothamBold
    NameLabel.Text = ""
    NameLabel.Parent = Frame

    local HealthBack = Instance.new("Frame")
    HealthBack.Size = UDim2.new(0, 140, 0, 15)
    HealthBack.Position = UDim2.new(0, 100, 0, 50)
    HealthBack.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    HealthBack.BorderSizePixel = 1
    HealthBack.BorderColor3 = Color3.fromRGB(255, 255, 255)
    HealthBack.Parent = Frame

    HealthFill = Instance.new("Frame")
    HealthFill.Size = UDim2.new(1, 0, 1, 0)
    HealthFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    HealthFill.BorderSizePixel = 0
    HealthFill.Parent = HealthBack
end

local function destroyGUI()
    if ScreenGui then
        ScreenGui:Destroy()
        ScreenGui = nil
        Frame, PFPImage, NameLabel, HealthFill = nil
    end
end

RunService.RenderStepped:Connect(function()
    local camEnabled = getgenv().Divine.Camlock.enabled
    local target = getgenv().Divine.Targetaim.target

    if getgenv().EnemyStats.Enabled and camEnabled and target then
        if not ScreenGui then createGUI() end

        local player = target
        if player and player.UserId then
            local thumb, isReady = Players:GetUserThumbnailAsync(player.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420)
            if isReady then
                PFPImage.Image = thumb
            end
            NameLabel.Text = player.DisplayName or player.Name
        end

        local char = player.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.MaxHealth > 0 then
            local hpPercent = humanoid.Health / humanoid.MaxHealth
            HealthFill.Size = UDim2.new(math.clamp(hpPercent, 0, 1), 0, 1, 0)
            HealthFill.BackgroundColor3 = Color3.fromRGB(255 - (hpPercent * 255), hpPercent * 255, 0)
        end
    else
        destroyGUI()
    end
end)

getgenv().GroundShotDetection = {
    Enabled = false,
    GroundShotThreshold = 0.5,
    DetectionRange = 20
}

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local function isGroundShot(hitPosition)
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end

    local feetPosition = rootPart.Position - Vector3.new(0, humanoid.HipHeight, 0)
    local distanceToFeet = (hitPosition - feetPosition).Magnitude
    return distanceToFeet <= getgenv().GroundShotDetection.GroundShotThreshold
end

local function onCharacterAdded(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
end

localPlayer.CharacterAdded:Connect(onCharacterAdded)

workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
    workspace.CurrentCamera.ChildAdded:Connect(function(child)
        if getgenv().GroundShotDetection.Enabled then
            if child:IsA("BasePart") and child.Name == "Bullet" then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart and (child.Position - rootPart.Position).Magnitude <= getgenv().GroundShotDetection.DetectionRange then
                    if isGroundShot(child.Position) then
                    end
                end
            end
        end
    end)
end)

getgenv().charactermod = {
    enabled = true,
    speed = 27,
    jump = 50,
    fov = 70,
    _dev = {},
}

local main = Tabs.combat:AddLeftGroupbox('Main Settings')
local air = Tabs.combat:AddRightGroupbox('Air Settings')
local ag = Tabs.combat:AddRightGroupbox('Anti ground shots')
local speed = Tabs.combat:AddRightGroupbox('CFrame')
local hit_group = Tabs.visuals:AddLeftGroupbox('Hit Sounds')
local circleBox = Tabs.visuals:AddLeftGroupbox('Visuals')
local imp = Tabs.visuals:AddRightGroupbox('important')
local hvh = Tabs.raging:AddLeftGroupbox('HVH Orbit')
local ant = Tabs.visuals:AddRightGroupbox('Antilocks')
local at = Tabs.raging:AddRightGroupbox('Autos')

getgenv().AutoReloadEnabled = false

local function autoReload()
    while getgenv().AutoReloadEnabled do
        task.wait(0.1)

        local character = game.Players.LocalPlayer.Character
        if character then
            local tool = character:FindFirstChildWhichIsA("Tool")
            if tool then
                local ammo = tool:FindFirstChild("AMMO")
                local reloadEvent = tool:FindFirstChildWhichIsA("RemoteEvent")

                if ammo and reloadEvent and ammo.Value == 0 then
                    reloadEvent:FireServer()
                    task.wait(1)
                end
            end
        end
    end
end

at:AddToggle('autoReloadToggle', {
    Text = 'Enable auto reload',
    Default = false,
    Callback = function(state)
        getgenv().AutoReloadEnabled = state
        if state then
            task.spawn(autoReload)
        end
    end
})

at:AddButton(
    'Auto Shoot',
    function()
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Parent = game.CoreGui

        local button = Instance.new("TextButton")
        button.Size = UDim2.new(0, 80, 0, 60)
        button.Position = UDim2.new(0.5, -100, 0.5, -25)
        button.Text = "Auto Shoot"
        button.BackgroundColor3 = Color3.new(0, 0, 0)
        button.BackgroundTransparency = 0.3
        button.TextColor3 = Color3.new(1, 1, 1)
        button.Font = Enum.Font.Code
        button.TextWrapped = true
        button.TextScaled = true
        button.Parent = ScreenGui
        button.Draggable = true
        button.Active = true
        button.Selectable = true

        local Outline = Instance.new("UIStroke")
        Outline.Color = Color3.fromRGB(250, 250, 250)
        Outline.Thickness = 1
        Outline.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        Outline.Parent = button

        local UICorner = Instance.new("UICorner")
        UICorner.Parent = button

        local autoShooting = false

        local function autoShoot()
            while autoShooting do
                local character = game.Players.LocalPlayer.Character
                if character then
                    local tool = character:FindFirstChildOfClass("Tool")
                    if tool and tool:FindFirstChild("Handle") then
                        tool:Activate()
                    end
                end
                task.wait()
            end
        end

        button.MouseButton1Click:Connect(
            function()
                autoShooting = not autoShooting
                button.Text = autoShooting and "Auto On" or "Auto Off"

                if autoShooting then
                    task.spawn(autoShoot)
                end
            end
        )
    end
)

getgenv().antilock = {
    enabled = false,
    mode = "Sky" -- or predbreaker
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

RunService.Heartbeat:Connect(function()
    local player = Players.LocalPlayer
    local character = player.Character

    if character and character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = character.HumanoidRootPart
        local vel = humanoidRootPart.Velocity

        if getgenv().antilock.enabled then
            if getgenv().antilock.mode == "Predbreaker" then
                humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            elseif getgenv().antilock.mode == "Sky" then
                humanoidRootPart.Velocity = Vector3.new(0, 100, 0)
            end
        end

        RunService.RenderStepped:Wait()
        humanoidRootPart.Velocity = vel
    end
end)

ant:AddToggle(
    'Toggle antilock',
    {
        Text = 'Enable Anti Lock',
        Default = false,
        Tooltip = 'Toggle Anti Lock system',
        Callback = function(state)
            getgenv().antilock.enabled = state
        end
    }
)

ant:AddDropdown(
    'Antilockmode',
    {
        Values = {'Sky', 'Predbreaker'},
        Default = getgenv().antilock.mode,
        Multi = false,
        Text = 'Anti Lock Mode',
        Tooltip = 'Select Anti Lock mode',
        Callback = function(value)
            getgenv().antilock.mode = value
        end
    }
)

hvh:AddToggle('orbit', {
   Text =  'Enable Orbit',
   Default = getgenv().orbit.enabled,
   Callback = function(value) getgenv().orbit.enabled = value end
})

hvh:AddInput('ortbitz', {
   Text = 'Orbit Speed',
   Default = getgenv().orbit.speed,
   Callback = function(value) getgenv().orbit.speed = tonumber(value) or 400 end
})

hvh:AddInput('orbitz', {
   Text = 'Orbit Height',
   Default = getgenv().orbit.height,
   Callback = function(value) getgenv().orbit.height = tonumber(value) or 5 end
})

hvh:AddInput('oree', {
   Text = 'Orbit Distance',
   Default = getgenv().orbit.distance,
   Callback = function(value) getgenv().orbit.distance = tonumber(value) or 10 end
})

main:AddToggle('enable_cam', {
    Text = 'Enable Camlock',
    Default = getgenv().Divine.Camlock.enabled,
    Callback = function(state)
        getgenv().Divine.Camlock.enabled = state
        if state and not getgenv().Divine.Camlock.target then
            local enemy = FindNearestEnemy()
            if enemy then
                getgenv().Divine.Camlock.target = enemy
            end
        end
    end
})

main:AddToggle('enable', {
    Text = 'Enable TargetAim',
    Default = getgenv().Divine.Targetaim.enabled,
    Callback = function(state)
    getgenv().Divine.Targetaim.enabled = state
    if state and not getgenv().Divine.Targetaim.target then
        local enemy = FindNearestEnemy()
        if enemy then
            getgenv().Divine.Targetaim.target = enemy
        end
    end
end
})

main:AddToggle("TrigToggle", {
    Text = "Enable Triggerbot",
    Default = false,
    Callback = function(val)
        getgenv().triggerbot.Enabled = val
        print("Triggerbot:", val)
    end
})

main:AddSlider("CooldownSlide", {
    Text = "Trigger Cooldown",
    Default = 0.01,
    Min = 0,
    Max = 0.2,
    Rounding = 3,
    Compact = false,
    Callback = function(val)
        getgenv().triggerbot.TriggerCooldown = val
    end
})

main:AddToggle("visualize_enemy", {
    Text = "Visualize",
    Default = getgenv().Divine.Visualize.enabled,
    Callback = function(val)
        getgenv().Divine.Visualize.enabled = val
    end
})

main:AddToggle("stats_enemy", {
    Text = "Enemy Stats",
    Default = getgenv().EnemyStats.Enabled,
    Callback = function(val)
        getgenv().EnemyStats.Enabled = val
    end
})

main:AddToggle('enable_aav', {
    Text = 'Enable AntiAimViewer',
    Default = false,
    Callback = function(value) getgenv().AntiAimViewer = value end
})

main:AddToggle("AutoPrediction", {
	Text = "Auto Prediction",
	Default = false,
	Callback = function(state)
		if state then
			startAutoPrediction()
		else
			stopAutoPrediction()
		end
	end
})

main:AddToggle('resolver', {
    Text = 'Resolver',
    Default = Divine.Camlock.resolver,
    Callback = function(value) Divine.Camlock.resolver = value end
})

main:AddDropdown('method', {
    Text = 'Hook Method',
    Values = {'Namecall', 'Index'},
    Default = getgenv().Divine.Targetaim.Method,
    Callback = function(value)
         getgenv().Divine.Targetaim.Method = value:lower()
    end
})

main:AddDropdown('hitpart', {
    Text = 'Hit Part',
    Values = {'HumanoidRootPart', 'UpperTorso', 'LowerTorso', 'Head'},
    Default = getgenv().Divine.Targetaim.HitPart,
    Callback = function(value)
        getgenv().Divine.Targetaim.HitPart = value
        getgenv().Divine.Camlock.HitPart = value
    end
})

main:AddInput('HorizontalPrediction', {
    Text = 'Horizontal Prediction',
    Default = getgenv().Divine.Targetaim.HorizontalPrediction,
    Callback = function(val)
        local num = tonumber(val) or 0.1
        getgenv().Divine.Targetaim.HorizontalPrediction = num
        getgenv().Divine.Camlock.HorizontalPrediction = num
    end
})

main:AddInput('VerticalPrediction', {
    Text = 'Vertical Prediction',
    Default = getgenv().Divine.Targetaim.VerticalPrediction,
    Callback = function(val)
        local num = tonumber(val) or 0.1
        getgenv().Divine.Targetaim.VerticalPrediction = num
        getgenv().Divine.Camlock.VerticalPrediction = num
    end
})

main:AddInput('smoothness', {
    Text = 'Smoothness',
    Default = getgenv().Divine.Settings.Smoothness,
    Callback = function(val)
        getgenv().Divine.Settings.Smoothness = tonumber(val) or 0.1
    end
})

main:AddToggle("HitboxToggle", {
    Text = "Enable Hitbox Expander",
    Default = getgenv().stile.hitbox_expander.Enabled,
    Callback = function(state)
        getgenv().stile.hitbox_expander.Enabled = state
        _G.Disabled = not state
    end
})

main:AddInput("HitboxSizeInput", {
    Text = "Hitbox Size",
    Default = tostring(getgenv().stile.hitbox_expander.Size),
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local size = tonumber(value)
        if size then
            getgenv().stile.hitbox_expander.Size = size
            
            print("Hitbox size set to:", size)
        end
    end
})

main:AddToggle("SelfChamsToggle", {
    Text = "Enable Self Chams",
    Default = getgenv().stile.Visuals.Self.Enabled,
    Callback = function(state)
        getgenv().stile.Visuals.Self.Enabled = state
        print("Self Chams:", state)
    end
})

circleBox:AddToggle("circle_enabled", {
	Text = "Enable FOV",
	Default = getgenv().exlareCircle.enabled,
	Callback = function(state)
		getgenv().exlareCircle.enabled = state
		updateexlareCircle()
	end
})

circleBox:AddInput("circle_radius", {
	Text = "FOV Radius",
	Default = tostring(getgenv().exlareCircle.radius),
	Numeric = true,
	Finished = true,
	Callback = function(val)
		local number = tonumber(val)
		if number then
			getgenv().exlareCircle.radius = number
			updateexlareCircle()
		end
	end
})

circleBox:AddToggle("crosshair_enabled", {
	Text = "Enable Crosshair",
	Default = getgenv().crosshair.enabled,
	Callback = function(state)
		getgenv().crosshair.enabled = state
	end
})

circleBox:AddDropdown('Crosshair_Type', {
    Values = {'Center', 'Mouse'},
    Default = 'Center',
    Text = 'Crosshair Mode',
    Callback = function(value)
        getgenv().crosshair.mode = value:lower()
    end
})

circleBox:AddInput("crosshair_radius", {
	Text = "Crosshair Radius",
	Default = tostring(getgenv().crosshair.radius),
	Numeric = true,
	Finished = true,
	Callback = function(val)
		local num = tonumber(val)
		if num then
			getgenv().crosshair.radius = num
		end
	end
})

--// SPINBOT SETUP
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local SpinEnabled = false
local SpinSpeed = 15

--// SPINBOT LOOP
RunService.RenderStepped:Connect(function()
    if SpinEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local root = LocalPlayer.Character.HumanoidRootPart
        root.CFrame = root.CFrame * CFrame.Angles(0, math.rad(SpinSpeed), 0)
    end
end)

--// UI ELEMENTS
circleBox:AddToggle("SpinbotToggle", {
    Text = "Enable Spinbot",
    Default = false,
    Tooltip = "Toggle character spin",
}):OnChanged(function(value)
    SpinEnabled = value
end)

circleBox:AddSlider("SpinSpeedSlider", {
    Text = "Spin Speed",
    Default = 15,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Compact = false,
}):OnChanged(function(value)
    SpinSpeed = value
end)

circleBox:AddToggle("esp_box", {
	Text = "Target Box",
	Default = getgenv().exlare.esp.box,
	Callback = function(state)
		getgenv().exlare.esp.box = state
	end
})

circleBox:AddToggle("esp_tracer", {
	Text = "Target Tracer",
	Default = getgenv().exlare.esp.tracer,
	Callback = function(state)
		getgenv().exlare.esp.tracer = state
	end
})

-- MAIN ENABLE
circleBox:AddToggle("ESPEnabled", {
    Text = "Enable ESP",
    Default = ESPSettings.Enabled,
    Callback = function(state)
        ESPSettings.Enabled = state
    end
})

circleBox:AddToggle("TeamCheck", {
    Text = "Team Check",
    Default = ESPSettings.TeamCheck,
    Callback = function(val)
        ESPSettings.TeamCheck = val
    end
})

circleBox:AddDivider()

-- BOX SECTION
circleBox:AddToggle("BoxEnabled", {
    Text = "2D Box",
    Default = ESPSettings.Box.Enabled,
    Callback = function(val)
        ESPSettings.Box.Enabled = val
    end
})

circleBox:AddSlider("BoxThickness", {
    Text = "Box Thickness",
    Default = ESPSettings.Box.Thickness,
    Min = 1,
    Max = 5,
    Callback = function(val)
        ESPSettings.Box.Thickness = val
    end
})

circleBox:AddToggle("BoxOutline", {
    Text = "Box Outline",
    Default = ESPSettings.Box.UseOutline,
    Callback = function(val)
        ESPSettings.Box.UseOutline = val
    end
})

circleBox:AddColorPicker("BoxColor", {
    Text = "Box Color",
    Default = ESPSettings.Box.Color,
    Callback = function(c)
        ESPSettings.Box.Color = c
    end
})

circleBox:AddColorPicker("BoxOutlineColor", {
    Text = "Box Outline Color",
    Default = ESPSettings.Box.OutlineColor,
    Callback = function(c)
        ESPSettings.Box.OutlineColor = c
    end
})

circleBox:AddDivider()

-- TRACER SECTION
circleBox:AddToggle("TracerEnabled", {
    Text = "Tracer",
    Default = ESPSettings.Tracer.Enabled,
    Callback = function(val)
        ESPSettings.Tracer.Enabled = val
    end
})

circleBox:AddSlider("TracerThickness", {
    Text = "Tracer Thickness",
    Default = ESPSettings.Tracer.Thickness,
    Min = 1,
    Max = 5,
    Callback = function(val)
        ESPSettings.Tracer.Thickness = val
    end
})

circleBox:AddToggle("TracerUseOutline", {
    Text = "Tracer Outline",
    Default = ESPSettings.Tracer.UseOutline,
    Callback = function(val)
        ESPSettings.Tracer.UseOutline = val
    end
})

circleBox:AddColorPicker("TracerColor", {
    Text = "Tracer Color",
    Default = ESPSettings.Tracer.Color,
    Callback = function(c)
        ESPSettings.Tracer.Color = c
    end
})

circleBox:AddColorPicker("TracerOutlineColor", {
    Text = "Tracer Outline Color",
    Default = ESPSettings.Tracer.OutlineColor,
    Callback = function(c)
        ESPSettings.Tracer.OutlineColor = c
    end
})

circleBox:AddDropdown("TracerOrigin", {
    Text = "Tracer Origin",
    Values = { "Bottom", "Middle", "Mouse" },
    Default = ESPSettings.Tracer.From,
    Callback = function(opt)
        ESPSettings.Tracer.From = opt
    end
})

circleBox:AddToggle("TracerFollowMouse", {
    Text = "Follow Mouse",
    Default = ESPSettings.Tracer.FollowMouse,
    Callback = function(val)
        ESPSettings.Tracer.FollowMouse = val
    end
})

circleBox:AddDivider()

-- NAMETAG
circleBox:AddToggle("NameTagEnabled", {
    Text = "Name Tag",
    Default = ESPSettings.NameTag.Enabled,
    Callback = function(val)
        ESPSettings.NameTag.Enabled = val
    end
})

circleBox:AddColorPicker("NameTagColor", {
    Text = "Name Color",
    Default = ESPSettings.NameTag.Color,
    Callback = function(c)
        ESPSettings.NameTag.Color = c
    end
})

circleBox:AddColorPicker("NameTagOutlineColor", {
    Text = "Name Outline Color",
    Default = ESPSettings.NameTag.OutlineColor,
    Callback = function(c)
        ESPSettings.NameTag.OutlineColor = c
    end
})

circleBox:AddDivider()

-- DISTANCE
circleBox:AddToggle("DistanceEnabled", {
    Text = "Distance",
    Default = ESPSettings.Distance.Enabled,
    Callback = function(val)
        ESPSettings.Distance.Enabled = val
    end
})

circleBox:AddColorPicker("DistanceColor", {
    Text = "Distance Color",
    Default = ESPSettings.Distance.Color,
    Callback = function(c)
        ESPSettings.Distance.Color = c
    end
})

circleBox:AddColorPicker("DistanceOutlineColor", {
    Text = "Distance Outline Color",
    Default = ESPSettings.Distance.OutlineColor,
    Callback = function(c)
        ESPSettings.Distance.OutlineColor = c
    end
})

circleBox:AddDivider()

-- HEALTHBAR
circleBox:AddToggle("HealthBarEnabled", {
    Text = "Health Bar",
    Default = ESPSettings.HealthBar.Enabled,
    Callback = function(val)
        ESPSettings.HealthBar.Enabled = val
    end
})

circleBox:AddColorPicker("HealthBarOutlineColor", {
    Text = "Health Outline Color",
    Default = ESPSettings.HealthBar.OutlineColor,
    Callback = function(c)
        ESPSettings.HealthBar.OutlineColor = c
    end
})

circleBox:AddDivider()

-- HIGHLIGHT
circleBox:AddToggle("HighlightEnabled", {
    Text = "Highlight",
    Default = ESPSettings.Highlight.Enabled,
    Callback = function(val)
        ESPSettings.Highlight.Enabled = val
    end
})

circleBox:AddColorPicker("HighlightFill", {
    Text = "Highlight Fill",
    Default = ESPSettings.Highlight.FillColor,
    Callback = function(c)
        ESPSettings.Highlight.FillColor = c
    end
})

circleBox:AddColorPicker("HighlightOutline", {
    Text = "Highlight Outline",
    Default = ESPSettings.Highlight.OutlineColor,
    Callback = function(c)
        ESPSettings.Highlight.OutlineColor = c
    end
})

circleBox:AddSlider("HighlightTransparency", {
    Text = "Highlight Transparency",
    Default = ESPSettings.Highlight.Transparency,
    Min = 0,
    Max = 1,
    Increment = 0.05,
    Callback = function(val)
        ESPSettings.Highlight.Transparency = val
    end
})

hit_group:AddToggle('detection', {
    Text = 'Hit Detection',
    Default = hit.detection,
    Callback = function(value) hit.detection = value end
})

hit_group:AddToggle('logs', {
    Text = 'Hit Logs',
    Default = hit.logs,
    Callback = function(value) hit.logs = value end
})

hit_group:AddToggle('sound_enabled', {
    Text = 'Hit Sound',
    Default = hit.sound_enabled,
    Callback = function(value) hit.sound_enabled = value end
})

hit_group:AddInput('notify_duration', {
    Default = hit.notify_duration,
    Text = 'Notify Duration',
    Numeric = true,
    Finished = true,
    Callback = function(value)
        hit.notify_duration = tonumber(value) or 1
    end
})

hit_group:AddDropdown('sounds', {
    Values = hitSoundsNames,
    Default = hit.sound_id,
    Text = 'Hit Sound',
    Callback = function(value)
        hit.sound_id = value
    end
})

hit_group:AddInput('sound_volume', {
    Default = hit.sound_volume,
    Text = 'Sound Volume',
    Numeric = true,
    Finished = true,
    Callback = function(value)
        hit.sound_volume = tonumber(value) or 1
    end
})

imp:AddToggle("FOVToggle", {
    Text = "Enable Custom FOV",
    Default = false,
    Callback = function(state)
        FOVEnabled = state
    end
})

-- // Slider
imp:AddSlider("FOVSlider", {
    Text = "FOV Amount",
    Default = 120,
    Min = 70,
    Max = 120,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        FOVValue = value
    end
})

-- // Force FOV Loop
task.spawn(function()
    while task.wait() do
        if FOVEnabled then
            Camera.FieldOfView = FOVValue
        end
    end
end)

imp:AddButton('Rejoin Same Server', function()
    local TeleportService = game:GetService("TeleportService")
    local Players = game:GetService("Players")
    local localPlayer = Players.LocalPlayer

    TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, localPlayer)
end)

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local displayName = player.DisplayName

local function getGreeting()
    local hour = os.date("*t").hour
    if hour < 12 then
        return "Good Morning"
    elseif hour < 18 then
        return "Good Afternoon"
    else
        return "Good Evening"
    end
end

local function startGreetingUpdater(label)
    task.spawn(function()
        while true do
            label:SetText(getGreeting() .. ", " .. displayName .. "!")
            task.wait(30) -- check every 30 seconds
        end
    end)
end

-- Load Macro Button
imp:AddButton("Load Macro", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/CookieScript/Trace.Iol/refs/heads/main/Macro", true))()
end)

-- Adjust Speed Slider
imp:AddSlider("MacroSpeed", {
    Text = "Adjust Speed",
    Default = 1,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        _G.MacroSpeed = Value
    end
})

-- Set default speed variable
_G.MacroSpeed = 1


local greetingLabel = main:AddLabel("...") -- placeholder
startGreetingUpdater(greetingLabel)

air:AddToggle('enabled', {
    Text = 'Auto Air',
    Default = Divine.AutoAir.enabled,
    Callback = function(value) Divine.AutoAir.enabled = value end
})

air:AddInput('Offset', {
    Default = Divine.AutoAir.jumpOffset,
    Text = 'jump offset',
    Callback = function(value) Divine.AutoAir.jumpOffset = tonumber(value) or 0.8 end
})

air:AddInput('Offset', {
    Default = Divine.AutoAir.jumpOffset,
    Text = 'jump offset',
    Callback = function(value) Divine.AutoAir.jumpOffset = tonumber(value) or 0.8 end
})

air:AddInput('dly', {
    Default = Divine.AutoAir.delay,
    Text = 'Delay',
    Callback = function(value) Divine.AutoAir.delay = tonumber(value) or 0.1 end
})

air:AddDropdown('airpary', {
    Values = {'RightFoot', 'LowerTorso', 'HumanoidRootPart', 'Head', 'UpperTorso'},
    Default = Divine.AutoAir.AirPart,
    Text = 'Auto Air Part',
    Callback = function(value) Divine.AutoAir.AirPart = value end
})

ag:AddToggle('gsEnabled', {
    Text = 'enable',
    Default = getgenv().GroundShotDetection.Enabled,
    Callback = function(value)
        getgenv().GroundShotDetection.Enabled = value
    end
})

ag:AddInput('gsThreshold', {
    Default = '0.5',
    Numeric = true,
    Finished = true,
    Text = 'threshold',
    Callback = function(value)
        getgenv().GroundShotDetection.GroundShotThreshold = tonumber(value) or 5
    end
})

ag:AddInput('gsRange', {
    Default = '20',
    Numeric = true,
    Finished = true,
    Text = 'range',
    Callback = function(value)
        getgenv().GroundShotDetection.DetectionRange = tonumber(value) or 20
    end
})

speed:AddToggle('enablecf', {
    Text = 'Enable CFrame',
    Default = getgenv().cframe.settings.enabled,
    Callback = function(value) getgenv().cframe.settings.enabled = value end
})

speed:AddSlider('cframe_speed', {
    Text = 'CFrame Speed',
    Default = getgenv().cframe.settings.speed or 1,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        getgenv().cframe.settings.speed = value
    end
})

runservice.RenderStepped:Connect(
    function()
        local _tick = tick()

        if _tick - last_render > crosshair.refreshrate then
            last_render = _tick

            local position =
                (crosshair.mode == "center" and camera.ViewportSize / 2 or
                crosshair.mode == "mouse" and inputservice:GetMouseLocation() or
                crosshair.position)

            local text_1 = drawings.text[1]
            local text_2 = drawings.text[2]

            text_1.Visible = crosshair.enabled
            text_2.Visible = crosshair.enabled

            if crosshair.enabled then
                local text_x = text_1.TextBounds.X + text_2.TextBounds.X

                text_1.Position =
                    position +
                    Vector2.new(
                        -text_x / 2,
                        crosshair.radius + (crosshair.resize and crosshair.resize_max or crosshair.length) + 15
                    )
                text_2.Position = text_1.Position + Vector2.new(text_1.TextBounds.X)
                text_2.Color = crosshair.color

                for idx = 1, 4 do
                    local outline = drawings.crosshair[idx]
                    local inline = drawings.crosshair[idx + 4]

                    local angle = (idx - 1) * 90
                    local length = crosshair.length

                    if crosshair.spin then
                        local spin_angle = -_tick * crosshair.spin_speed % crosshair.spin_max
                        angle =
                            angle +
                            tweenservice:GetValue(spin_angle / 360, crosshair.spin_style, Enum.EasingDirection.InOut) *
                                360
                    end

                    if crosshair.resize then
                        local resize_length = tick() * crosshair.resize_speed % 180
                        length = crosshair.resize_min + math.sin(math.rad(resize_length)) * crosshair.resize_max
                    end

                    inline.Visible = true
                    inline.Color = crosshair.color
                    inline.From = position + solve(angle, crosshair.radius)
                    inline.To = position + solve(angle, crosshair.radius + length)
                    inline.Thickness = crosshair.width

                    outline.Visible = true
                    outline.From = position + solve(angle, crosshair.radius - 1)
                    outline.To = position + solve(angle, crosshair.radius + length + 1)
                    outline.Thickness = crosshair.width + 1.5
                end
            else
                for idx = 1, 4 do
                    drawings.crosshair[idx].Visible = false
                    drawings.crosshair[idx + 4].Visible = false
                end
            end
        end
    end
)

local player = game:GetService("Players").LocalPlayer
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local camera = Workspace.CurrentCamera

local lastTrigger = 0

local function isOtherPlayer(part)
    local model = part:FindFirstAncestorOfClass("Model")
    if not model or model == player.Character then return false end

    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end

    local bodyEffects = model:FindFirstChild("BodyEffects")
    local isKnocked = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
    local isGrabbed = model:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
    if isKnocked or isGrabbed then return false end

    if model:FindFirstChildOfClass("ForceField") then return false end

    return Players:GetPlayerFromCharacter(model) ~= nil
end

local function isToolAllowed()
    local character = player.Character
    local backpack = player:FindFirstChildOfClass("Backpack")
    if not character or not backpack then return false end

    for _, item in ipairs(character:GetChildren()) do
        if item:IsA("Tool") and getgenv().triggerbot.BlacklistedTools[item.Name] then
            return false
        end
    end

    for _, item in ipairs(backpack:GetChildren()) do
        if item:IsA("Tool") and getgenv().triggerbot.BlacklistedTools[item.Name] then
            return false
        end
    end

    return true
end

RunService.RenderStepped:Connect(function()
    if not getgenv().triggerbot.Enabled then return end

    local character = player.Character
    if not character or not isToolAllowed() then return end

    local now = tick()
    if now - lastTrigger < getgenv().triggerbot.TriggerCooldown then return end

    local origin = camera.CFrame.Position
    local direction = camera.CFrame.LookVector * 1000

    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local result = Workspace:Raycast(origin, direction, raycastParams)

    if result and result.Instance and isOtherPlayer(result.Instance) then
        lastTrigger = now
        print("Triggerbot Fired!")

        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA("Tool") then
                tool:Activate()
            end
        end
    end
end)

setup_hooks()

-- SETTINGS TAB UI
local SettingsTab = Tabs.Settings

-- Apply theme manager UI
thememanager:SetLibrary(library)
thememanager:SetFolder("Elysian")
thememanager:ApplyToTab(SettingsTab)

-- Apply save manager UI
savemanager:SetLibrary(library)
savemanager:SetFolder("Elysian/configs")
savemanager:SetIgnoreIndexes({"MenuKeybind"})
savemanager:BuildConfigSection(SettingsTab)

-- Auto-load last config
savemanager:LoadAutoloadConfig()


library:Notify("Eclipse loaded successfully", 5)

game.StarterGui:SetCore("SendNotification", {
    Title = "Eclipse",
    Text = "Eclipse successfully loaded",
    Duration = 3
})

task.spawn(function()
    while task.wait() do
        if getgenv().stile.hitbox_expander.Enabled then
            for _, player in pairs(game.Players:GetPlayers()) do
                if player ~= game.Players.LocalPlayer and player.Character then
                    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        pcall(function()
                            local size = getgenv().stile.hitbox_expander.Size
                            hrp.Size = Vector3.new(size, size, size)
                            hrp.Transparency = 1
                            hrp.Color = Color3.new(1,1,1)
                            hrp.Material = Enum.Material.SmoothPlastic
                            hrp.CanCollide = false
                        end)
                    end
                end
            end
        end
    end
end)

local function applySelfChams(char)
    if not getgenv().stile.Visuals.Self.Enabled then return end

    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Material = Enum.Material.Neon
            part.Color = getgenv().stile.Visuals.Self.Color
            part.CanCollide = false
        end
    end
end

local lp = game.Players.LocalPlayer

lp.CharacterAdded:Connect(function(char)
    task.wait(0.5)
    applySelfChams(char)
end)

if lp.Character then
    applySelfChams(lp.Character)
end

--// FULL ESP SOURCE ENGINE (USE WITH LINEORIA)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- DRAWING CONSTRUCTORS
local function NewText(color, outline)
    local t = Drawing.new("Text")
    t.Size = 13
    t.Center = true
    t.Outline = true
    t.Visible = false
    t.Color = color
    t.OutlineColor = outline
    t.Font = 2
    return t
end

local function NewLine(thick, color)
    local l = Drawing.new("Line")
    l.Visible = false
    l.Color = color
    l.Thickness = thick
    return l
end

local function NewQuad(thick, color)
    local q = Drawing.new("Quad")
    q.Visible = false
    q.Color = color
    q.Thickness = thick
    q.Filled = false
    return q
end

-- GET TRACER ORIGIN
local function GetOrigin()
    local vp = Camera.ViewportSize

    if ESPSettings.Tracer.FollowMouse then
        local pos = UserInputService:GetMouseLocation()
        return Vector2.new(pos.X, pos.Y + 36)

    elseif ESPSettings.Tracer.From == "Middle" then
        return vp / 2

    else -- Bottom
        return Vector2.new(vp.X / 2, vp.Y)
    end
end

-- ADD ESP TO PLAYER
local function AddESP(plr)
    if plr == LocalPlayer then return end

    -- DRAW OBJECTS
    local esp = {
        Box = NewQuad(ESPSettings.Box.Thickness, ESPSettings.Box.Color),
        BoxOutline = ESPSettings.Box.UseOutline and NewQuad(ESPSettings.Box.Thickness+1, ESPSettings.Box.OutlineColor),
        Tracer = ESPSettings.Tracer.Enabled and NewLine(ESPSettings.Tracer.Thickness, ESPSettings.Tracer.Color),
        TracerOutline = ESPSettings.Tracer.UseOutline and NewLine(ESPSettings.Tracer.Thickness+1, ESPSettings.Tracer.OutlineColor),
        NameTag = ESPSettings.NameTag.Enabled and NewText(ESPSettings.NameTag.Color, ESPSettings.NameTag.OutlineColor),
        Distance = ESPSettings.Distance.Enabled and NewText(ESPSettings.Distance.Color, ESPSettings.Distance.OutlineColor),
        HealthBG = ESPSettings.HealthBar.Enabled and NewLine(3, ESPSettings.HealthBar.OutlineColor),
        Health = ESPSettings.HealthBar.Enabled and NewLine(1.5, Color3.new(0,1,0)),
    }

    local highlight
    if ESPSettings.Highlight.Enabled then
        highlight = Instance.new("Highlight")
        highlight.FillColor = ESPSettings.Highlight.FillColor
        highlight.OutlineColor = ESPSettings.Highlight.OutlineColor
        highlight.FillTransparency = ESPSettings.Highlight.Transparency
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    end

    -- RENDER LOOP
    RunService.RenderStepped:Connect(function()
        if not ESPSettings.Enabled then
            for _, d in pairs(esp) do if d then d.Visible=false end end
            if highlight then highlight.Enabled = false end
            return
        end

        local char = plr.Character
        if not char then
            for _, d in pairs(esp) do if d then d.Visible=false end end
            if highlight then highlight.Enabled = false end
            return
        end

        local hrp = char:FindFirstChild("HumanoidRootPart")
        local head = char:FindFirstChild("Head")
        local hum = char:FindFirstChild("Humanoid")

        if not hrp or not head or not hum or hum.Health <= 0 then
            for _, d in pairs(esp) do if d then d.Visible=false end end
            if highlight then highlight.Enabled = false end
            return
        end

        -- TEAM CHECK
        if ESPSettings.TeamCheck and plr.Team == LocalPlayer.Team then
            for _, d in pairs(esp) do if d then d.Visible=false end end
            if highlight then highlight.Enabled = false end
            return
        end

        -- VIEWPORT CHECK
        local pos, onscreen = Camera:WorldToViewportPoint(hrp.Position)
        if not onscreen then
            for _, d in pairs(esp) do if d then d.Visible=false end end
            if highlight then highlight.Enabled = false end
            return
        end

        -- BOX SIZE
        local headPos = Camera:WorldToViewportPoint(head.Position)
        local height = math.clamp((Vector2.new(headPos.X, headPos.Y) - Vector2.new(pos.X, pos.Y)).Magnitude, 2, 300)
        local w = height
        local h = height * 2
        local x,y = pos.X, pos.Y

        -- BOX + OUTLINE
        if ESPSettings.Box.Enabled and esp.Box then
            local function Apply(q, s)
                q.PointA = Vector2.new(x-s, y-h)
                q.PointB = Vector2.new(x+s, y-h)
                q.PointC = Vector2.new(x+s, y+h)
                q.PointD = Vector2.new(x-s, y+h)
                q.Visible = true
            end
            Apply(esp.Box, w)
            if esp.BoxOutline then Apply(esp.BoxOutline, w+1) end
        end

        -- TRACER
        if ESPSettings.Tracer.Enabled and esp.Tracer then
            local origin = GetOrigin()
            esp.Tracer.From = origin
            esp.Tracer.To = Vector2.new(x, y+h)
            esp.Tracer.Visible = true

            if esp.TracerOutline then
                esp.TracerOutline.From = origin
                esp.TracerOutline.To = Vector2.new(x, y+h)
                esp.TracerOutline.Visible = true
            end
        end

        -- NAME TAG
        if ESPSettings.NameTag.Enabled and esp.NameTag then
            esp.NameTag.Text = plr.Name
            esp.NameTag.Position = Vector2.new(x, y-h-14)
            esp.NameTag.Visible = true
        end

        -- DISTANCE
        if ESPSettings.Distance.Enabled and esp.Distance then
            local dist = math.floor((Camera.CFrame.Position - hrp.Position).Magnitude)
            esp.Distance.Text = "["..dist.."m]"
            esp.Distance.Position = Vector2.new(x, y+h+2)
            esp.Distance.Visible = true
        end

        -- HEALTH BAR
        if ESPSettings.HealthBar.Enabled and esp.HealthBG then
            local percent = hum.Health / hum.MaxHealth
            local bottom = Vector2.new(x-w-5, y+h)
            local top = Vector2.new(x-w-5, y-h)

            esp.HealthBG.From = bottom
            esp.HealthBG.To = top
            esp.HealthBG.Visible = true

            esp.Health.From = bottom
            esp.Health.To = bottom:Lerp(top, percent)
            esp.Health.Color = Color3.new(1-percent, percent, 0)
            esp.Health.Visible = true
        end

        -- HIGHLIGHT
        if highlight then
            highlight.Adornee = char
            highlight.Enabled = ESPSettings.Highlight.Enabled
            highlight.FillColor = ESPSettings.Highlight.FillColor
            highlight.OutlineColor = ESPSettings.Highlight.OutlineColor
            highlight.FillTransparency = ESPSettings.Highlight.Transparency
            if not highlight.Parent then
                highlight.Parent = char
            end
        end
    end)
end

-- PLAYER HOOKS
for _, plr in pairs(Players:GetPlayers()) do
    AddESP(plr)
end

Players.PlayerAdded:Connect(function(plr)
    AddESP(plr)
end)