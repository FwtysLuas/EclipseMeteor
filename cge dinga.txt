local runservice = game:GetService("RunService")
local camera = workspace.CurrentCamera
local players = game:GetService("Players")
local replicatedStorage = game:GetService("ReplicatedStorage")
local localplayer = players.LocalPlayer
local inputservice = game:GetService("UserInputService")
local mouse = localplayer:GetMouse()
local SoundService = game:GetService("SoundService")
local Stats = game:GetService("Stats")
local Player = game:GetService("Players").LocalPlayer

-- // FIX UI (REQUIRED)
getgenv().triggerbot = getgenv().triggerbot or {
    Enabled = false,
    TriggerCooldown = 0.01,
    BlacklistedTools = {},
}

getgenv().stile = {
    hitbox_expander = {
        Enabled = false,
        Size = 15,
        Transparency = 0.5,
        Color = Color3.fromRGB(255, 0, 0),
    },

    Visuals = {
        Self = {
            Enabled = false,
            Color = Color3.fromRGB(255, 255, 255),
        }
    }
}

local MacroEnabled = false
local EmoteEnabled = false
local EmoteID = "15610015346" -- YungBlud Emote

local repo = 'https://raw.githubusercontent.com/deividcomsono/Obsidian/main/'

local library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local thememanager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local savemanager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
Library:SetWatermarkVisibility(true)

local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter += 1

    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end

    local currentTime = os.date("%H:%M:%S")

    Library:SetWatermark(('Eclipse.lol| %s fps | %s ms | Time: %s'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue()),
        currentTime
    ))
end)

local ToggleGui = Instance.new("ScreenGui")
ToggleGui.Name = "UIToggle"
ToggleGui.ResetOnSpawn = false
ToggleGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ToggleGui.Parent = game.CoreGui

local ToggleButton = Instance.new("ImageButton")
ToggleButton.Size = UDim2.new(0, 70, 0, 50)
ToggleButton.Position = UDim2.new(1, -110, 0, 10)
ToggleButton.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
ToggleButton.BackgroundTransparency = 1
ToggleButton.Image = "rbxassetid://109014824057194"
ToggleButton.Parent = ToggleGui

Instance.new("UICorner", ToggleButton).CornerRadius = UDim.new(0, 10)

local isVisible = true
ToggleButton.MouseButton1Click:Connect(function()
    if library and library.Toggle then
        library:Toggle()
        isVisible = not isVisible
        -- same image both states as you chose Option 1
        ToggleButton.Image = "rbxassetid://109014824057194"
    end
end)

local game_name = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name

local Hooks = {}

getgenv().Divine = {
  Settings = {
    Smoothness = 0.1,
  },

  Camlock = {
    enabled = true,
    resolver = false,
    HorizontalPrediction = 0.1,
    VerticalPrediction = 0.1,
    HitPart = "HumanoidRootPart",
    target = nil
  },

  Targetaim = {
    enabled = true,
    target = nil,
    predictionEnabled = true,
    HorizontalPrediction = 0.1,
    VerticalPrediction = 0.1,
    HitPart = "HumanoidRootPart",
    Method = "Namecall"
  },

  AutoAir = {
   enabled = true,
   jumpOffset = -0.20,
   fallOffset = 0.15, -- NEW (Psalm style)
   delay = 0.22,
   AirPart = "RightFoot"
}
}

getgenv().crosshair = {
    enabled = false,
    refreshrate = 0,
    mode = "center",
    position = Vector2.new(0, 0),
    width = 1.5,
    length = 10,
    radius = 11,
    color = Color3.fromRGB(255, 255, 255),
    spin = true,
    spin_speed = 120,
    spin_max = 200,
    spin_style = Enum.EasingStyle.Circular,
    resize = true,
    resize_speed = 150,
    resize_min = 5,
    resize_max = 22
}

local Window = library:CreateWindow({
    Title = 'Elysian',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2,
    Footer = "1.0.0 ELYSIAN REWRITE",
    Size = UDim2.fromOffset(620, 500),
    Icon = "rbxasset://132866879342416"
})

local Options = library.Options

local Tabs = {
    combat = Window:AddTab("Combat", "crosshair"),
	 raging = Window:AddTab("Rage", "eye"),
    visuals = Window:AddTab("Miscellaneous ", "wrench"),
    Settings = Window:AddTab("Settings", "settings")
}

local Divine = getgenv().Divine

local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")
local SoundService = game:GetService("SoundService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Camera = workspace.CurrentCamera

local function FindNearestEnemy()
  local closest = nil
	local shortestDist = math.huge
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
			local pos = plr.Character.HumanoidRootPart.Position
			local screenPos, onScreen = Camera:WorldToViewportPoint(pos)
			if onScreen then
				local dist = (Vector2.new(screenPos.X, screenPos.Y) - Camera.ViewportSize / 2).Magnitude
				if dist < shortestDist then
					shortestDist = dist
					closest = plr
				end
			end
		end
	end
	return closest
end

local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local TextButton = Instance.new("ImageButton")
local UICorner = Instance.new("UICorner")

local CoreGui = game:GetService("CoreGui")
ScreenGui.Parent = CoreGui
ScreenGui.ResetOnSpawn = false
ScreenGui.Enabled = true

Frame.Parent = ScreenGui
Frame.BackgroundTransparency = 1
Frame.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame.Size = UDim2.new(0, 90, 0, 90)
Frame.Active = true

TextButton.Parent = Frame
TextButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
TextButton.BackgroundTransparency = 0.5
TextButton.Size = UDim2.new(0, 75, 0, 75)
TextButton.AnchorPoint = Vector2.new(0.5, 0.5)
TextButton.Position = UDim2.new(0.5, 0, 0.5, 0)
TextButton.Image = "rbxassetid://71218955901149"
TextButton.Active = true

local Outline = Instance.new("UIStroke")
Outline.Color = Color3.fromRGB(255, 255, 255)
Outline.Thickness = 1
Outline.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
Outline.Parent = TextButton

TextButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = TextButton.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

TextButton.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        TextButton.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
    end
end)

UICorner.Parent = TextButton
UICorner.CornerRadius = UDim.new(0, 12)

TextButton.MouseButton1Click:Connect(function()
    getgenv().Divine.Camlock.enabled = not getgenv().Divine.Camlock.enabled

    if getgenv().Divine.Camlock.enabled then
        local enemy = FindNearestEnemy()
        if enemy then
            getgenv().Divine.Camlock.target = enemy
            getgenv().Divine.Targetaim.target = enemy
            TextButton.Image = "rbxassetid://71218955901149"
            library:Notify("EC: Enabled, Target: " .. enemy.DisplayName, 2)
        else
            getgenv().Divine.Camlock.enabled = false
            getgenv().Divine.Targetaim.enabled = false
            TextButton.Image = "rbxassetid://71218955901149"
            library:Notify("No Target Found", 2)
        end
    else
        getgenv().Divine.Camlock.target = nil
        getgenv().Divine.Targetaim.target = nil
        TextButton.Image = "rbxassetid://71218955901149"
        library:Notify("EC: Spared Target", 2)
    end
end)

local UserInputService = game:GetService("UserInputService")

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end

    -------------------------------
    --  F KEY (Keyboard Toggle)
    -------------------------------
    if input.KeyCode == Enum.KeyCode.F then
        
        getgenv().Divine.Camlock.enabled = not getgenv().Divine.Camlock.enabled

        if getgenv().Divine.Camlock.enabled then
            local enemy = FindNearestEnemy()
            if enemy then
                getgenv().Divine.Camlock.target = enemy
                getgenv().Divine.Targetaim.target = enemy
                TextButton.Image = "rbxassetid://71218955901149"
                library:Notify("EC: Enabled (F), Target: " .. enemy.DisplayName, 2)
            end
        else
            getgenv().Divine.Camlock.target = nil
            getgenv().Divine.Targetaim.target = nil
            TextButton.Image = "rbxassetid://71218955901149"
            library:Notify("EC: Disabled (F)", 2)
        end
    end


    -------------------------------
    --  CONTROLLER BUTTON Y
    -------------------------------
    if input.KeyCode == Enum.KeyCode.ButtonY then
        
        getgenv().Divine.Camlock.enabled = not getgenv().Divine.Camlock.enabled

        if getgenv().Divine.Camlock.enabled then
            local enemy = FindNearestEnemy()
            if enemy then
                getgenv().Divine.Camlock.target = enemy
                getgenv().Divine.Targetaim.target = enemy
                TextButton.Image = "rbxassetid://71218955901149"
                library:Notify("EC: Enabled (Y), Target: " .. enemy.DisplayName, 2)
            end
        else
            getgenv().Divine.Camlock.target = nil
            getgenv().Divine.Targetaim.target = nil
            TextButton.Image = "rbxassetid://71218955901149"
            library:Notify("EC: Disabled (Y)", 2)
        end
    end
end)

RunService.Heartbeat:Connect(function()
    if Divine.Camlock.enabled then
        local camTarget = Divine.Camlock.target
        if camTarget and camTarget.Character then
            local camPart = camTarget.Character:FindFirstChild(Divine.Camlock.HitPart)
            if camPart then
                local camPredicted = camPart.Position
    + Vector3.new(
        camPart.Velocity.X * Divine.Camlock.HorizontalPrediction,
        camPart.Velocity.Y * Divine.Camlock.VerticalPrediction,
        camPart.Velocity.Z * Divine.Camlock.HorizontalPrediction
    )

                local camGoal = CFrame.new(Camera.CFrame.Position, camPredicted)
                Camera.CFrame = Camera.CFrame:Lerp(camGoal, Divine.Settings.Smoothness)
            end
        end
    end

    if Divine.AutoAir.enabled then
        local Victim = Divine.Targetaim.target
        if Victim and Victim.Character then
            local TargetRootPart = Victim.Character:FindFirstChild(Divine.AutoAir.AirPart)
            if TargetRootPart then
                local TargetVel = TargetRootPart.Velocity
                if TargetVel.Y > 25 then
                    local Character = LocalPlayer.Character
                    if Character then
                        local Tool = Character:FindFirstChildOfClass("Tool")
                        if Tool then
                            task.wait(Divine.AutoAir.delay)
                            Tool:Activate()
                        end
                    end
                end
            end
        end
    end
end)

if not Divine.Camlock.enabled and Divine.AutoAir.enabled then return end

if Divine.Targetaim.Method == "Namecall" then
    local __namecall
    __namecall = hookmetamethod(game, "__namecall", newcclosure(function(Self, ...)
        local Args = {...}
        local Method = tostring(getnamecallmethod())
        if not checkcaller() and Method == "FireServer" then
            for i, Arg in pairs(Args) do
                if typeof(Arg) == "Vector3" and Divine.Targetaim.enabled then
                    local Target = Divine.Targetaim.target
                    if Target and Target.Character and Divine.Targetaim.HitPart and Target.Character[Divine.Targetaim.HitPart] then
                        local TargetPart = Target.Character[Divine.Targetaim.HitPart]
                        local offset = Divine.AutoAir and Divine.AutoAir.jumpOffset or 0
                        local predictedPosition = TargetPart.Position
                            + Vector3.new(
    TargetPart.Velocity.X * Divine.Targetaim.HorizontalPrediction,
    TargetPart.Velocity.Y * Divine.Targetaim.VerticalPrediction,
    TargetPart.Velocity.Z * Divine.Targetaim.HorizontalPrediction
)

local velY = TargetPart.AssemblyLinearVelocity.Y
local Yoffset = 0

if velY > 1 then
    Yoffset = Divine.AutoAir.jumpOffset
elseif velY < -1 then
    Yoffset = Divine.AutoAir.fallOffset
end

predictedPosition = predictedPosition + Vector3.new(0, Yoffset, 0) 
                            + Vector3.new(0, Divine.AutoAir.jumpOffset, 0)

                        Args[i] = predictedPosition
                    end
                    return __namecall(Self, unpack(Args))
                end
            end
        end
        return __namecall(Self, ...)
    end))
end

local function setup_hooks()
    local function TargetFuturePosition()
        if not target or not target.Character then
            return nil
        end
        local target_part = target.Character[Divine.Targetaim.HitPart]
        if not target_part then
            return nil
        end

        local position = target_part.Position
        if Divine.Targetaim.predictionEnabled then
            position = position + (target_part.Velocity * Divine.Targetaim.Prediction) local Yoffset = 0

-- Psalm logic (Up = JumpOffset, Down = FallOffset)
if TargetPart.Velocity.Y > 1 then
    Yoffset = Divine.AutoAir.jumpOffset
elseif TargetPart.Velocity.Y < -1 then
    Yoffset = Divine.AutoAir.fallOffset
end

Args[i] = predictedPosition + Vector3.new(0, Yoffset, 0)
        end
        return position
    end

    Hooks[1] =
        hookmetamethod(
        mouse,
        "__index",
        newcclosure(
            function(self, index)
                if
                    index == "Hit" and locking and (Divine.Targetaim.Method == "Index") and
                        target and
                        target.Character and
                        target.Character:FindFirstChild(Divine.Targetaim.HitPart)
                 then
                    local futurePos = TargetFuturePosition()
                    if futurePos then
                        return CFrame.new(futurePos)
                    end
                end
                return Hooks[1](self, index)
            end
        )
    )
end

if not Divine.Targetaim.enabled then return end

local function onHeartbeat()
    if not getgenv().Divine.Camlock.resolver then return end

    for _, Target in pairs(Players:GetPlayers()) do
        if Target ~= LocalPlayer and Target.Character then
            local Character = Target.Character
            local Humanoid = Character:FindFirstChildOfClass("Humanoid")

            if Humanoid and Humanoid.MoveDirection.Magnitude > 0 then
                local moveVelocity = Humanoid.MoveDirection * 16

                local TargetParts = {
                    "HumanoidRootPart",
                    "UpperTorso",
                    "LowerTorso",
                    "LeftUpperLeg",
                    "LeftLowerLeg",
                    "RightUpperLeg",
                    "RightLowerLeg",
                    "Head",
                    "LeftHand",
                    "RightHand"
                }

                for _, partName in ipairs(TargetParts) do
                    local Part = Character:FindFirstChild(partName)
                    if Part then
                        Part.Velocity = moveVelocity
                        Part.AssemblyLinearVelocity = moveVelocity
                    end
                end
            end
        end
    end
end

RunService.Heartbeat:Connect(onHeartbeat)

getgenv().cframe = getgenv().cframe or {}
local cframe = getgenv().cframe

cframe.settings = {
    enabled = true,
    showbutton = true,
    speed = 1
}

local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")

if cframe.settings.showbutton then
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "SpeedCFrameGUI"
    ScreenGui.ResetOnSpawn = false
    ScreenGui.Parent = game.CoreGui

    local Button = Instance.new("TextButton")
    Button.Name = "SpeedCFrameButton"
    Button.Size = UDim2.new(0, 80, 0, 60)
    Button.Position = UDim2.new(0.55, -955, 0.57, -355)
    Button.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Button.BackgroundTransparency = 0.1
    Button.Text = cframe.settings.enabled and "CF: ON" or "CF: OFF"
    Button.TextColor3 = Color3.fromRGB(255, 255, 255)
    Button.Font = Enum.Font.Code
    Button.TextSize = 18
    Button.Parent = ScreenGui

    local Outline = Instance.new("UIStroke")
    Outline.Color = Color3.fromRGB(250, 250, 250)
    Outline.Thickness = 1
    Outline.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    Outline.Parent = Button

    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 10)
    UICorner.Parent = Button

    Button.MouseButton1Click:Connect(function()
        cframe.settings.enabled = not cframe.settings.enabled
        Button.Text = cframe.settings.enabled and "CF: ON" or "CF: OFF"
    end)

    -- Dragging support
    local dragging = false
    local startPos, startMousePos

    Button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            startPos = Button.Position
            startMousePos = input.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    Button.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - startMousePos
            Button.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y
            )
        end
    end)
end

if not getgenv().cframe.settings.showbutton then return end

RunService.Heartbeat:Connect(function()
    if cframe.settings.enabled and LocalPlayer.Character then
        local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if root and humanoid then
            local move_dir = humanoid.MoveDirection
            root.CFrame = root.CFrame + (move_dir * cframe.settings.speed)
        end
    end
end)

--// AUTO PREDICTION (DaStrike Blatant)

local function getPing()
    return game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
end

local autoPredictionRunning = false

local function startAutoPrediction()
    if autoPredictionRunning then return end
    autoPredictionRunning = true

    task.spawn(function()
        while autoPredictionRunning do

            local ping = getPing()
            local pred

            if ping <= 40 then
                pred = 0.1458912       -- 40ms Blatant
            elseif ping <= 50 then
                pred = 0.1403592       -- 50ms Blatant
            elseif ping <= 60 then
                pred = 0.1213536       -- 60ms Blatant
            elseif ping <= 70 then
                pred = 0.1355798        -- 70ms Blatant
            elseif ping <= 80 then
                pred = 0.1226346       -- 80ms Blatant
            elseif ping <= 90 then
                pred = 0.1400822       -- 90ms Blatant
            elseif ping <= 100 then
                pred = 0.1436029425      -- 100ms Blatant
            elseif ping <= 120 then
                pred = 0.1155657825
            elseif ping <= 140 then
                pred = 0.1491826658
            else
                pred = 0.1404715572
            end

           getgenv().Divine.Targetaim.HorizontalPrediction = pred
getgenv().Divine.Targetaim.VerticalPrediction = pred

getgenv().Divine.Camlock.HorizontalPrediction = pred
getgenv().Divine.Camlock.VerticalPrediction = pred

            task.wait(1)
        end
    end)
end

local function stopAutoPrediction()
    autoPredictionRunning = false
end
local function stopAutoPrediction()
	autoPredictionRunning = false
end

getgenv().exlareCircle = getgenv().exlareCircle or {
	enabled = false,
	color = Color3.fromRGB(255, 255, 255),
	radius = 100,
	circle = nil
}

if not getgenv().exlareCircle.circle then
	getgenv().exlareCircle.circle = Drawing.new("Circle")
	getgenv().exlareCircle.circle.Filled = false
	getgenv().exlareCircle.circle.Thickness = 1
end

function updateexlareCircle()
	if getgenv().exlareCircle.circle then
		getgenv().exlareCircle.circle.Visible = getgenv().exlareCircle.enabled
		getgenv().exlareCircle.circle.Color = getgenv().exlareCircle.color
		getgenv().exlareCircle.circle.Radius = getgenv().exlareCircle.radius
		getgenv().exlareCircle.circle.Position = Vector2.new(
			workspace.CurrentCamera.ViewportSize.X / 2,
			workspace.CurrentCamera.ViewportSize.Y / 2
		)
	end
end

game:GetService("RunService").RenderStepped:Connect(function()
	if getgenv().exlareCircle.enabled and getgenv().exlareCircle.circle then
		getgenv().exlareCircle.circle.Position = Vector2.new(
			workspace.CurrentCamera.ViewportSize.X / 2,
			workspace.CurrentCamera.ViewportSize.Y / 2
		)
	end
end)

local old
old =
    hookfunction(
    Drawing.new,
    function(class, properties)
        local drawing = old(class)
        for i, v in next, properties or {} do
            drawing[i] = v
        end
        return drawing
    end
)

local function solve(angle, radius)
    return Vector2.new(math.sin(math.rad(angle)) * radius, math.cos(math.rad(angle)) * radius)
end

local last_render = 0
local drawings = {
    crosshair = {},
    text = {
        Drawing.new("Text", {Size = 13, Font = 2, Outline = true, Text = "Eclipse", Color = Color3.new(1, 1, 1)}),
        Drawing.new("Text", {Size = 13, Font = 2, Outline = true, Text = " .lol", Color = Color3.new(0.5, 0.5, 0.5)})
    }
}

for idx = 1, 4 do
    drawings.crosshair[idx] = Drawing.new("Line")
    drawings.crosshair[idx + 4] = Drawing.new("Line")
end

local box = Drawing.new("Square")
box.Visible = false
box.Color = Color3.new(1, 1, 1)
box.Thickness = 1
box.Filled = false

local tracer = Drawing.new("Line")
tracer.Visible = false
tracer.Color = Color3.new(1, 1, 1)
tracer.Thickness = 1

getgenv().exlare = getgenv().exlare or {}
getgenv().exlare.esp = {
	box = false,
	tracer = false
}

RunService.RenderStepped:Connect(function()
	local target = getgenv().Divine and getgenv().Divine.Targetaim and getgenv().Divine.Targetaim.target

	if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") and target.Character:FindFirstChild("Head") then
		local hrp = target.Character.HumanoidRootPart
		local head = target.Character.Head

		local hrpPos, hrpOnScreen = Camera:WorldToViewportPoint(hrp.Position)
		local headPos, headOnScreen = Camera:WorldToViewportPoint(head.Position)

		local screenHeight = math.abs(hrpPos.Y - headPos.Y) * 2
		local boxSize = Vector2.new(screenHeight / 1.5, screenHeight)

		if getgenv().exlare.esp.box and hrpOnScreen then
			box.Size = boxSize
			box.Position = Vector2.new(hrpPos.X - boxSize.X / 2, hrpPos.Y - boxSize.Y / 2)
			box.Visible = true
		else
			box.Visible = false
		end

		if getgenv().exlare.esp.tracer and hrpOnScreen then
			tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
			tracer.To = Vector2.new(hrpPos.X, hrpPos.Y)
			tracer.Visible = true
		else
			tracer.Visible = false
		end
	else
		box.Visible = false
		tracer.Visible = false
	end
end)

getgenv().hit = {
    detection = true,
    logs = true,
    notify_duration = 1,
    sound_enabled = true,
    sound_id = "Neverlose",
    sound_volume = 1
}

local HitSoundId = {
    Bameware = "rbxassetid://3124331820",
    Neverlose = "rbxassetid://6534948092",
    Bell = "rbxassetid://6534947240",
    Bubble = "rbxassetid://6534947588",
    Pick = "rbxassetid://1347140027",
    Pop = "rbxassetid://198598793",
    Rust = "rbxassetid://1255040462",
    Sans = "rbxassetid://3188795283",
    Fart = "rbxassetid://130833677",
    Big = "rbxassetid://5332005053",
    Vine = "rbxassetid://5332680810",
    Bruh = "rbxassetid://4578740568",
    Skeet = "rbxassetid://5633695679",
    Fatality = "rbxassetid://6534947869",
    Bonk = "rbxassetid://5766898159",
    Minecraft = "rbxassetid://4018616850"
}

local hitSoundsNames = {"Bameware", "Neverlose", "Bubble", "Pick", "Pop", "Rust", "Sans", "Fart", "Big", "Vine", "Bruh", "Skeet", "Fatality", "Bonk","Minecraft"}

local last_health = {}

RunService.PostSimulation:Connect(function()
    local Divine = getgenv().Divine
    if not Divine then return end

    local target = Divine.Targetaim and Divine.Targetaim.target
    local locking = Divine.Camlock and Divine.Camlock.enabled
    local humanoid = target and target.Character and target.Character:FindFirstChild("Humanoid")

    if locking and target and humanoid and hit.detection then
        local current_health = humanoid.Health

        if not last_health[target.UserId] then
            last_health[target.UserId] = current_health
        end

        if current_health < last_health[target.UserId] then
            if hit.sound_enabled and HitSoundId[hit.sound_id] then
                local sound = Instance.new("Sound")
                sound.SoundId = HitSoundId[hit.sound_id]
                sound.Volume = hit.sound_volume
                sound.Parent = workspace
                sound:Play()
                game:GetService("Debris"):AddItem(sound, 2)
            end

            if hit.logs and library then
                library:Notify("Hit: " .. target.DisplayName, hit.notify_duration)
            end
        end

        last_health[target.UserId] = current_health
    end
end)

getgenv().orbit = {
	enabled = false,
	distance = 10,
	height = 5,
	speed = 400,
	angle = 0
}

game:GetService("RunService").Heartbeat:Connect(function(dt)
	if not getgenv().orbit.enabled then return end

	local lp = game.Players.LocalPlayer
	if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then return end

	local target = getgenv().Divine and getgenv().Divine.Camlock and getgenv().Divine.Camlock.target
	if not target or not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then return end

	local root = lp.Character.HumanoidRootPart
	local targetRoot = target.Character.HumanoidRootPart

	getgenv().orbit.angle += dt * getgenv().orbit.speed
	local angleRad = math.rad(getgenv().orbit.angle)

	local offset = Vector3.new(
		math.cos(angleRad) * getgenv().orbit.distance,
		getgenv().orbit.height,
		math.sin(angleRad) * getgenv().orbit.distance
	)

	local orbitPosition = targetRoot.Position + offset
	root.CFrame = CFrame.new(orbitPosition, targetRoot.Position)
end)

getgenv().Divine.Visualize = getgenv().Divine.Visualize or {enabled = false}

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local highlight = Instance.new("Highlight")
highlight.FillColor = Color3.fromRGB(10, 10, 10)
highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
highlight.FillTransparency = 0.4
highlight.OutlineTransparency = 0
highlight.Enabled = false
highlight.Parent = game:GetService("CoreGui")

local dot = Drawing.new("Circle")
dot.Color = Color3.fromRGB(250, 250, 250)
dot.Thickness = 2
dot.Filled = true
dot.Radius = 4
dot.Visible = false

RunService.RenderStepped:Connect(function()
    if not getgenv().Divine.Visualize.enabled then
        highlight.Enabled = false
        dot.Visible = false
        return
    end

    local target = getgenv().Divine.Targetaim and getgenv().Divine.Targetaim.target
    if target and target.Character then
        local hrp = target.Character:FindFirstChild("HumanoidRootPart")

        highlight.Adornee = target.Character
        highlight.Enabled = true

        if hrp then
            local pos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(hrp.Position)
            dot.Visible = onScreen
            if onScreen then
                dot.Position = Vector2.new(pos.X, pos.Y)
            end
        end
    else
        highlight.Enabled = false
        dot.Visible = false
    end
end)

getgenv().AntiAimViewer = {
    enabled = false,
}

local China = setmetatable({}, {
    __index = function(_, service)
        return game:GetService(service)
    end
})

local Players = China.Players
local ReplicatedStorage = China.ReplicatedStorage
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local MainEvent = ReplicatedStorage:FindFirstChild("MainEvent")

local function Bypass(Entity)
    Entity.ChildAdded:Connect(function(Child)
        if Child:IsA("Tool") then
            Child.Activated:Connect(function()
                if MainEvent then
                    MainEvent:FireServer("UpdateMousePos", Mouse.Hit.Position)
                end
            end)
        end
    end)
end

local function Alive(Player)
    return Player and Player.Character and Player.Character:FindFirstChild("Humanoid") and Player.Character:FindFirstChild("Head")
end

LocalPlayer.CharacterAdded:Connect(function(Character)
    Bypass(Character)
end)

if getgenv().AntiAimViewer then
    if Alive(LocalPlayer) then
        LocalPlayer.Character.Humanoid:UnequipTools()
        Bypass(LocalPlayer.Character)
    end
end

local Hook
Hook = hookmetamethod(game, "__namecall", function(self, ...)
    local Args = {...}
    local Method = getnamecallmethod()

    if not checkcaller() and Method == "FireServer" and self.Name == "MainEvent" and Args[1] == "UpdateMousePos" then
        if getgenv().AntiAimViewer then
            Args[2] = Mouse.Hit.Position
        end
        return self.FireServer(self, unpack(Args))
    end

    return Hook(self, ...)
end)

getgenv().EnemyStats = {
    Enabled = false,
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local ScreenGui
local Frame, PFPImage, NameLabel, HealthFill

local function createGUI()
    if ScreenGui then return end

    ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Parent = game.CoreGui

    Frame = Instance.new("Frame")
    Frame.Size = UDim2.new(0, 250, 0, 100)
    Frame.AnchorPoint = Vector2.new(0.5, 0.5)
    Frame.Position = UDim2.new(0.5, 0, 0.85, 0)
    Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Frame.BorderSizePixel = 2
    Frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    Frame.Parent = ScreenGui

    PFPImage = Instance.new("ImageLabel")
    PFPImage.Size = UDim2.new(0, 80, 0, 80)
    PFPImage.Position = UDim2.new(0, 10, 0, 10)
    PFPImage.BackgroundTransparency = 1
    PFPImage.Parent = Frame

    NameLabel = Instance.new("TextLabel")
    NameLabel.Size = UDim2.new(0, 140, 0, 30)
    NameLabel.Position = UDim2.new(0, 100, 0, 10)
    NameLabel.BackgroundTransparency = 1
    NameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    NameLabel.TextScaled = true
    NameLabel.Font = Enum.Font.GothamBold
    NameLabel.Text = ""
    NameLabel.Parent = Frame

    local HealthBack = Instance.new("Frame")
    HealthBack.Size = UDim2.new(0, 140, 0, 15)
    HealthBack.Position = UDim2.new(0, 100, 0, 50)
    HealthBack.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    HealthBack.BorderSizePixel = 1
    HealthBack.BorderColor3 = Color3.fromRGB(255, 255, 255)
    HealthBack.Parent = Frame

    HealthFill = Instance.new("Frame")
    HealthFill.Size = UDim2.new(1, 0, 1, 0)
    HealthFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    HealthFill.BorderSizePixel = 0
    HealthFill.Parent = HealthBack
end

local function destroyGUI()
    if ScreenGui then
        ScreenGui:Destroy()
        ScreenGui = nil
        Frame, PFPImage, NameLabel, HealthFill = nil
    end
end

RunService.RenderStepped:Connect(function()
    local camEnabled = getgenv().Divine.Camlock.enabled
    local target = getgenv().Divine.Targetaim.target

    if getgenv().EnemyStats.Enabled and camEnabled and target then
        if not ScreenGui then createGUI() end

        local player = target
        if player and player.UserId then
            local thumb, isReady = Players:GetUserThumbnailAsync(player.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420)
            if isReady then
                PFPImage.Image = thumb
            end
            NameLabel.Text = player.DisplayName or player.Name
        end

        local char = player.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.MaxHealth > 0 then
            local hpPercent = humanoid.Health / humanoid.MaxHealth
            HealthFill.Size = UDim2.new(math.clamp(hpPercent, 0, 1), 0, 1, 0)
            HealthFill.BackgroundColor3 = Color3.fromRGB(255 - (hpPercent * 255), hpPercent * 255, 0)
        end
    else
        destroyGUI()
    end
end)

getgenv().GroundShotDetection = {
    Enabled = false,
    GroundShotThreshold = 0.5,
    DetectionRange = 20
}

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local function isGroundShot(hitPosition)
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end

    local feetPosition = rootPart.Position - Vector3.new(0, humanoid.HipHeight, 0)
    local distanceToFeet = (hitPosition - feetPosition).Magnitude
    return distanceToFeet <= getgenv().GroundShotDetection.GroundShotThreshold
end

local function onCharacterAdded(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
end

localPlayer.CharacterAdded:Connect(onCharacterAdded)

workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
    workspace.CurrentCamera.ChildAdded:Connect(function(child)
        if getgenv().GroundShotDetection.Enabled then
            if child:IsA("BasePart") and child.Name == "Bullet" then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart and (child.Position - rootPart.Position).Magnitude <= getgenv().GroundShotDetection.DetectionRange then
                    if isGroundShot(child.Position) then
                    end
                end
            end
        end
    end)
end)

getgenv().charactermod = {
    enabled = true,
    speed = 27,
    jump = 50,
    fov = 70,
    _dev = {},
}

local main = Tabs.combat:AddLeftGroupbox('Main Settings')
local air = Tabs.combat:AddRightGroupbox('Air Settings')
local ag = Tabs.combat:AddRightGroupbox('Anti ground shots')
local speed = Tabs.combat:AddRightGroupbox('CFrame')
local hit_group = Tabs.visuals:AddLeftGroupbox('Hit Sounds')
local circleBox = Tabs.visuals:AddLeftGroupbox('Visuals')
local imp = Tabs.visuals:AddRightGroupbox('important')
local hvh = Tabs.raging:AddLeftGroupbox('HVH Orbit')
local ant = Tabs.visuals:AddRightGroupbox('Antilocks')
local at = Tabs.raging:AddRightGroupbox('Autos')

getgenv().AutoReloadEnabled = false

local function autoReload()
    while getgenv().AutoReloadEnabled do
        task.wait(0.1)

        local character = game.Players.LocalPlayer.Character
        if character then
            local tool = character:FindFirstChildWhichIsA("Tool")
            if tool then
                local ammo = tool:FindFirstChild("AMMO")
                local reloadEvent = tool:FindFirstChildWhichIsA("RemoteEvent")

                if ammo and reloadEvent and ammo.Value == 0 then
                    reloadEvent:FireServer()
                    task.wait(1)
                end
            end
        end
    end
end

at:AddToggle('autoReloadToggle', {
    Text = 'Enable auto reload',
    Default = false,
    Callback = function(state)
        getgenv().AutoReloadEnabled = state
        if state then
            task.spawn(autoReload)
        end
    end
})

at:AddButton(
    'Auto Shoot',
    function()
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Parent = game.CoreGui

        local button = Instance.new("TextButton")
        button.Size = UDim2.new(0, 80, 0, 60)
        button.Position = UDim2.new(0.5, -100, 0.5, -25)
        button.Text = "Auto Shoot"
        button.BackgroundColor3 = Color3.new(0, 0, 0)
        button.BackgroundTransparency = 0.3
        button.TextColor3 = Color3.new(1, 1, 1)
        button.Font = Enum.Font.Code
        button.TextWrapped = true
        button.TextScaled = true
        button.Parent = ScreenGui
        button.Draggable = true
        button.Active = true
        button.Selectable = true

        local Outline = Instance.new("UIStroke")
        Outline.Color = Color3.fromRGB(250, 250, 250)
        Outline.Thickness = 1
        Outline.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        Outline.Parent = button

        local UICorner = Instance.new("UICorner")
        UICorner.Parent = button

        local autoShooting = false

        local function autoShoot()
            while autoShooting do
                local character = game.Players.LocalPlayer.Character
                if character then
                    local tool = character:FindFirstChildOfClass("Tool")
                    if tool and tool:FindFirstChild("Handle") then
                        tool:Activate()
                    end
                end
                task.wait()
            end
        end

        button.MouseButton1Click:Connect(
            function()
                autoShooting = not autoShooting
                button.Text = autoShooting and "Auto On" or "Auto Off"

                if autoShooting then
                    task.spawn(autoShoot)
                end
            end
        )
    end
)

getgenv().antilock = {
    enabled = false,
    mode = "Sky" -- or predbreaker
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

RunService.Heartbeat:Connect(function()
    local player = Players.LocalPlayer
    local character = player.Character

    if character and character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = character.HumanoidRootPart
        local vel = humanoidRootPart.Velocity

        if getgenv().antilock.enabled then
            if getgenv().antilock.mode == "Predbreaker" then
                humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            elseif getgenv().antilock.mode == "Sky" then
                humanoidRootPart.Velocity = Vector3.new(0, 100, 0)
            end
        end

        RunService.RenderStepped:Wait()
        humanoidRootPart.Velocity = vel
    end
end)

ant:AddToggle(
    'Toggle antilock',
    {
        Text = 'Enable Anti Lock',
        Default = false,
        Tooltip = 'Toggle Anti Lock system',
        Callback = function(state)
            getgenv().antilock.enabled = state
        end
    }
)

ant:AddDropdown(
    'Antilockmode',
    {
        Values = {'Sky', 'Predbreaker'},
        Default = getgenv().antilock.mode,
        Multi = false,
        Text = 'Anti Lock Mode',
        Tooltip = 'Select Anti Lock mode',
        Callback = function(value)
            getgenv().antilock.mode = value
        end
    }
)

hvh:AddToggle('orbit', {
   Text =  'Enable Orbit',
   Default = getgenv().orbit.enabled,
   Callback = function(value) getgenv().orbit.enabled = value end
})

hvh:AddInput('ortbitz', {
   Text = 'Orbit Speed',
   Default = getgenv().orbit.speed,
   Callback = function(value) getgenv().orbit.speed = tonumber(value) or 400 end
})

hvh:AddInput('orbitz', {
   Text = 'Orbit Height',
   Default = getgenv().orbit.height,
   Callback = function(value) getgenv().orbit.height = tonumber(value) or 5 end
})

hvh:AddInput('oree', {
   Text = 'Orbit Distance',
   Default = getgenv().orbit.distance,
   Callback = function(value) getgenv().orbit.distance = tonumber(value) or 10 end
})

main:AddToggle('enable_cam', {
    Text = 'Enable Camlock',
    Default = getgenv().Divine.Camlock.enabled,
    Callback = function(state)
        getgenv().Divine.Camlock.enabled = state
        if state and not getgenv().Divine.Camlock.target then
            local enemy = FindNearestEnemy()
            if enemy then
                getgenv().Divine.Camlock.target = enemy
            end
        end
    end
})

main:AddToggle('enable', {
    Text = 'Enable TargetAim',
    Default = getgenv().Divine.Targetaim.enabled,
    Callback = function(state)
    getgenv().Divine.Targetaim.enabled = state
    if state and not getgenv().Divine.Targetaim.target then
        local enemy = FindNearestEnemy()
        if enemy then
            getgenv().Divine.Targetaim.target = enemy
        end
    end
end
})

main:AddToggle("TrigToggle", {
    Text = "Enable Triggerbot",
    Default = false,
    Callback = function(val)
        getgenv().triggerbot.Enabled = val
        print("Triggerbot:", val)
    end
})

main:AddSlider("CooldownSlide", {
    Text = "Trigger Cooldown",
    Default = 0.01,
    Min = 0,
    Max = 0.2,
    Rounding = 3,
    Compact = false,
    Callback = function(val)
        getgenv().triggerbot.TriggerCooldown = val
    end
})

main:AddToggle("visualize_enemy", {
    Text = "Visualize",
    Default = getgenv().Divine.Visualize.enabled,
    Callback = function(val)
        getgenv().Divine.Visualize.enabled = val
    end
})

main:AddToggle("stats_enemy", {
    Text = "Enemy Stats",
    Default = getgenv().EnemyStats.Enabled,
    Callback = function(val)
        getgenv().EnemyStats.Enabled = val
    end
})

main:AddToggle('enable_aav', {
    Text = 'Enable AntiAimViewer',
    Default = false,
    Callback = function(value) getgenv().AntiAimViewer = value end
})

main:AddToggle("AutoPrediction", {
	Text = "Auto Prediction",
	Default = false,
	Callback = function(state)
		if state then
			startAutoPrediction()
		else
			stopAutoPrediction()
		end
	end
})

main:AddToggle('resolver', {
    Text = 'Resolver',
    Default = Divine.Camlock.resolver,
    Callback = function(value) Divine.Camlock.resolver = value end
})

main:AddDropdown('method', {
    Text = 'Hook Method',
    Values = {'Namecall', 'Index'},
    Default = getgenv().Divine.Targetaim.Method,
    Callback = function(value)
         getgenv().Divine.Targetaim.Method = value:lower()
    end
})

main:AddDropdown('hitpart', {
    Text = 'Hit Part',
    Values = {'HumanoidRootPart', 'UpperTorso', 'LowerTorso', 'Head'},
    Default = getgenv().Divine.Targetaim.HitPart,
    Callback = function(value)
        getgenv().Divine.Targetaim.HitPart = value
        getgenv().Divine.Camlock.HitPart = value
    end
})

main:AddInput('HorizontalPrediction', {
    Text = 'Horizontal Prediction',
    Default = getgenv().Divine.Targetaim.HorizontalPrediction,
    Callback = function(val)
        local num = tonumber(val) or 0.1
        getgenv().Divine.Targetaim.HorizontalPrediction = num
        getgenv().Divine.Camlock.HorizontalPrediction = num
    end
})

main:AddInput('VerticalPrediction', {
    Text = 'Vertical Prediction',
    Default = getgenv().Divine.Targetaim.VerticalPrediction,
    Callback = function(val)
        local num = tonumber(val) or 0.1
        getgenv().Divine.Targetaim.VerticalPrediction = num
        getgenv().Divine.Camlock.VerticalPrediction = num
    end
})

main:AddInput('smoothness', {
    Text = 'Smoothness',
    Default = getgenv().Divine.Settings.Smoothness,
    Callback = function(val)
        getgenv().Divine.Settings.Smoothness = tonumber(val) or 0.1
    end
})

main:AddToggle("HitboxToggle", {
    Text = "Enable Hitbox Expander",
    Default = getgenv().stile.hitbox_expander.Enabled,
    Callback = function(state)
        getgenv().stile.hitbox_expander.Enabled = state
        _G.Disabled = not state
    end
})

main:AddInput("HitboxSizeInput", {
    Text = "Hitbox Size",
    Default = tostring(getgenv().stile.hitbox_expander.Size),
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local size = tonumber(value)
        if size then
            getgenv().stile.hitbox_expander.Size = size
            
            print("Hitbox size set to:", size)
        end
    end
})

main:AddToggle("SelfChamsToggle", {
    Text = "Enable Self Chams",
    Default = getgenv().stile.Visuals.Self.Enabled,
    Callback = function(state)
        getgenv().stile.Visuals.Self.Enabled = state
        print("Self Chams:", state)
    end
})

circleBox:AddToggle("circle_enabled", {
	Text = "Enable FOV",
	Default = getgenv().exlareCircle.enabled,
	Callback = function(state)
		getgenv().exlareCircle.enabled = state
		updateexlareCircle()
	end
})

circleBox:AddInput("circle_radius", {
	Text = "FOV Radius",
	Default = tostring(getgenv().exlareCircle.radius),
	Numeric = true,
	Finished = true,
	Callback = function(val)
		local number = tonumber(val)
		if number then
			getgenv().exlareCircle.radius = number
			updateexlareCircle()
		end
	end
})

circleBox:AddToggle("crosshair_enabled", {
	Text = "Enable Crosshair",
	Default = getgenv().crosshair.enabled,
	Callback = function(state)
		getgenv().crosshair.enabled = state
	end
})

circleBox:AddDropdown('Crosshair_Type', {
    Values = {'Center', 'Mouse'},
    Default = 'Center',
    Text = 'Crosshair Mode',
    Callback = function(value)
        getgenv().crosshair.mode = value:lower()
    end
})

circleBox:AddInput("crosshair_radius", {
	Text = "Crosshair Radius",
	Default = tostring(getgenv().crosshair.radius),
	Numeric = true,
	Finished = true,
	Callback = function(val)
		local num = tonumber(val)
		if num then
			getgenv().crosshair.radius = num
		end
	end
})

--// SPINBOT SETUP
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local SpinEnabled = false
local SpinSpeed = 15

--// SPINBOT LOOP
RunService.RenderStepped:Connect(function()
    if SpinEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local root = LocalPlayer.Character.HumanoidRootPart
        root.CFrame = root.CFrame * CFrame.Angles(0, math.rad(SpinSpeed), 0)
    end
end)

--// UI ELEMENTS
circleBox:AddToggle("SpinbotToggle", {
    Text = "Enable Spinbot",
    Default = false,
    Tooltip = "Toggle character spin",
}):OnChanged(function(value)
    SpinEnabled = value
end)

circleBox:AddSlider("SpinSpeedSlider", {
    Text = "Spin Speed",
    Default = 15,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Compact = false,
}):OnChanged(function(value)
    SpinSpeed = value
end)

circleBox:AddToggle("esp_box", {
	Text = "Target Box",
	Default = getgenv().exlare.esp.box,
	Callback = function(state)
		getgenv().exlare.esp.box = state
	end
})

circleBox:AddToggle("esp_tracer", {
	Text = "Target Tracer",
	Default = getgenv().exlare.esp.tracer,
	Callback = function(state)
		getgenv().exlare.esp.tracer = state
	end
})

circleBox:AddToggle("BoxESP", {Text = "2D Box", Default = default["2dbox"].enable})
    :OnChanged(function(v)
        default["2dbox"].enable = v
    end)

circleBox:AddColorpicker("BoxColor", {
    Text = "Box Color",
    Default = default["2dbox"].color
}):OnChanged(function(v)
    default["2dbox"].color = v
end)

circleBox:AddToggle("NameESP", {Text = "Name ESP", Default = default.name.enable})
    :OnChanged(function(v)
        default.name.enable = v
    end)

circleBox:AddDropdown("NamePlacement", {
    Text = "Name Placement",
    Values = {"Top", "Bottom", "Left", "Right"},
    Default = default.name.placement
}):OnChanged(function(v)
    default.name.placement = v
end)

circleBox:AddToggle("StudsESP", {Text = "Studs Distance", Default = default.studs.enable})
    :OnChanged(function(v)
        default.studs.enable = v
    end)

circleBox:AddToggle("ToolESP", {Text = "Tool ESP", Default = default.tool.enable})
    :OnChanged(function(v)
        default.tool.enable = v
    end)

circleBox:AddDropdown("ToolPlacement", {
    Text = "Tool Placement",
    Values = {"Top", "Bottom", "Left", "Right"},
    Default = default.tool.placement
}):OnChanged(function(v)
    default.tool.placement = v
end)

circleBox:AddToggle("FlagsESP", {Text = "Movement Flags", Default = default.flags.enable})
    :OnChanged(function(v)
        default.flags.enable = v
    end)

circleBox:AddDropdown("FlagsPlacement", {
    Text = "Flags Placement",
    Values = {"Left", "Right", "Top", "Bottom"},
    Default = default.flags.placement
}):OnChanged(function(v)
    default.flags.placement = v
end)

circleBox:AddToggle("SkeletonESP", {Text = "Skeleton ESP", Default = default.skeleton.enable})
    :OnChanged(function(v)
        default.skeleton.enable = v
    end)

circleBox:AddColorpicker("SkeletonColor", {
    Text = "Skeleton Color",
    Default = default.skeleton.color
}):OnChanged(function(v)
    default.skeleton.color = v
end)

circleBox:AddToggle("SkeletonOutline", {Text = "Skeleton Outline", Default = default.skeleton.outlineEnabled})
    :OnChanged(function(v)
        default.skeleton.outlineEnabled = v
    end)

circleBox:AddColorpicker("SkeletonOutlineColor", {
    Text = "Outline Color",
    Default = default.skeleton.outlineColor
}):OnChanged(function(v)
    default.skeleton.outlineColor = v
end)

circleBox:AddSlider("SkeletonThickness", {
    Text = "Line Thickness",
    Default = default.skeleton.lineThickness,
    Min = 1, Max = 5
}):OnChanged(function(v)
    default.skeleton.lineThickness = v
end)

circleBox:AddSlider("SkeletonOutlineThickness", {
    Text = "Outline Thickness",
    Default = default.skeleton.outlineThickness,
    Min = 1, Max = 8
}):OnChanged(function(v)
    default.skeleton.outlineThickness = v
end)

circleBox:AddToggle("TrailESP", {Text = "Trail ESP", Default = default.trail.enable})
    :OnChanged(function(v)
        default.trail.enable = v
    end)

circleBox:AddColorpicker("TrailColor", {
    Text = "Trail Color",
    Default = default.trail.rgb
}):OnChanged(function(v)
    default.trail.rgb = v
end)

circleBox:AddSlider("TrailThickness", {
    Text = "Trail Thickness",
    Min = 1, Max = 10,
    Default = default.trail.thickness
}):OnChanged(function(v)
    default.trail.thickness = v
end)

circleBox:AddToggle("HighlightESP", {Text = "Highlight ESP", Default = default.highlight.enable})
    :OnChanged(function(v)
        default.highlight.enable = v
    end)

circleBox:AddColorpicker("HighlightFill", {
    Text = "Fill Color",
    Default = default.highlight.fillColor
}):OnChanged(function(v)
    default.highlight.fillColor = v
end)

circleBox:AddColorpicker("HighlightOutline", {
    Text = "Outline Color",
    Default = default.highlight.outlineColor
}):OnChanged(function(v)
    default.highlight.outlineColor = v
end)

circleBox:AddSlider("HighlightFillTrans", {
    Text = "Fill Transparency",
    Min = 0, Max = 1,
    Float = 0.05,
    Default = default.highlight.fillTransparency
}):OnChanged(function(v)
    default.highlight.fillTransparency = v
end)

circleBox:AddSlider("HighlightOutlineTrans", {
    Text = "Outline Transparency",
    Min = 0, Max = 1,
    Float = 0.05,
    Default = default.highlight.outlineTransparency
}):OnChanged(function(v)
    default.highlight.outlineTransparency = v
end)

circleBox:AddToggle("MasterESP", {Text = "Enable All ESP", Default = false})
    :OnChanged(function(v)
        for _, cfg in pairs(default) do
            if type(cfg) == "table" and cfg.enable ~= nil then
                cfg.enable = v
            end
        end
    end)

hit_group:AddToggle('detection', {
    Text = 'Hit Detection',
    Default = hit.detection,
    Callback = function(value) hit.detection = value end
})

hit_group:AddToggle('logs', {
    Text = 'Hit Logs',
    Default = hit.logs,
    Callback = function(value) hit.logs = value end
})

hit_group:AddToggle('sound_enabled', {
    Text = 'Hit Sound',
    Default = hit.sound_enabled,
    Callback = function(value) hit.sound_enabled = value end
})

hit_group:AddInput('notify_duration', {
    Default = hit.notify_duration,
    Text = 'Notify Duration',
    Numeric = true,
    Finished = true,
    Callback = function(value)
        hit.notify_duration = tonumber(value) or 1
    end
})

hit_group:AddDropdown('sounds', {
    Values = hitSoundsNames,
    Default = hit.sound_id,
    Text = 'Hit Sound',
    Callback = function(value)
        hit.sound_id = value
    end
})

hit_group:AddInput('sound_volume', {
    Default = hit.sound_volume,
    Text = 'Sound Volume',
    Numeric = true,
    Finished = true,
    Callback = function(value)
        hit.sound_volume = tonumber(value) or 1
    end
})

imp:AddToggle("FOVToggle", {
    Text = "Enable Custom FOV",
    Default = false,
    Callback = function(state)
        FOVEnabled = state
    end
})

-- // Slider
imp:AddSlider("FOVSlider", {
    Text = "FOV Amount",
    Default = 120,
    Min = 70,
    Max = 120,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        FOVValue = value
    end
})

-- // Force FOV Loop
task.spawn(function()
    while task.wait() do
        if FOVEnabled then
            Camera.FieldOfView = FOVValue
        end
    end
end)

imp:AddButton('Rejoin Same Server', function()
    local TeleportService = game:GetService("TeleportService")
    local Players = game:GetService("Players")
    local localPlayer = Players.LocalPlayer

    TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, localPlayer)
end)

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local displayName = player.DisplayName

local function getGreeting()
    local hour = os.date("*t").hour
    if hour < 12 then
        return "Good Morning"
    elseif hour < 18 then
        return "Good Afternoon"
    else
        return "Good Evening"
    end
end

local function startGreetingUpdater(label)
    task.spawn(function()
        while true do
            label:SetText(getGreeting() .. ", " .. displayName .. "!")
            task.wait(30) -- check every 30 seconds
        end
    end)
end

-- Load Macro Button
imp:AddButton("Load Macro", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/CookieScript/Trace.Iol/refs/heads/main/Macro", true))()
end)

-- Adjust Speed Slider
imp:AddSlider("MacroSpeed", {
    Text = "Adjust Speed",
    Default = 1,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        _G.MacroSpeed = Value
    end
})

-- Set default speed variable
_G.MacroSpeed = 1


local greetingLabel = main:AddLabel("...") -- placeholder
startGreetingUpdater(greetingLabel)

air:AddToggle('enabled', {
    Text = 'Auto Air',
    Default = Divine.AutoAir.enabled,
    Callback = function(value) Divine.AutoAir.enabled = value end
})

air:AddInput('Offset', {
    Default = Divine.AutoAir.jumpOffset,
    Text = 'jump offset',
    Callback = function(value) Divine.AutoAir.jumpOffset = tonumber(value) or 0.8 end
})

air:AddInput('Offset', {
    Default = Divine.AutoAir.jumpOffset,
    Text = 'Fall offset',
    Callback = function(value) Divine.AutoAir.fallOffset = tonumber(value) or 0.8 end
})

air:AddInput('dly', {
    Default = Divine.AutoAir.delay,
    Text = 'Delay',
    Callback = function(value) Divine.AutoAir.delay = tonumber(value) or 0.1 end
})

air:AddDropdown('airpary', {
    Values = {'RightFoot', 'LowerTorso', 'HumanoidRootPart', 'Head', 'UpperTorso'},
    Default = Divine.AutoAir.AirPart,
    Text = 'Auto Air Part',
    Callback = function(value) Divine.AutoAir.AirPart = value end
})

ag:AddToggle('gsEnabled', {
    Text = 'enable',
    Default = getgenv().GroundShotDetection.Enabled,
    Callback = function(value)
        getgenv().GroundShotDetection.Enabled = value
    end
})

ag:AddInput('gsThreshold', {
    Default = '0.5',
    Numeric = true,
    Finished = true,
    Text = 'threshold',
    Callback = function(value)
        getgenv().GroundShotDetection.GroundShotThreshold = tonumber(value) or 5
    end
})

ag:AddInput('gsRange', {
    Default = '20',
    Numeric = true,
    Finished = true,
    Text = 'range',
    Callback = function(value)
        getgenv().GroundShotDetection.DetectionRange = tonumber(value) or 20
    end
})

speed:AddToggle('enablecf', {
    Text = 'Enable CFrame',
    Default = getgenv().cframe.settings.enabled,
    Callback = function(value) getgenv().cframe.settings.enabled = value end
})

speed:AddSlider('cframe_speed', {
    Text = 'CFrame Speed',
    Default = getgenv().cframe.settings.speed or 1,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        getgenv().cframe.settings.speed = value
    end
})

-- // SAFE AUTO REFRESH (NEVER DISABLES)
task.spawn(function()
    while task.wait(7) do
        if getgenv().Divine.Targetaim.target == nil then
            local enemy = FindNearestEnemy()
            if enemy then
                getgenv().Divine.Targetaim.target = enemy
                print("[TargetAim] Refreshed Target: " .. enemy.Name)
            end
        end
    end
end)

runservice.RenderStepped:Connect(
    function()
        local _tick = tick()

        if _tick - last_render > crosshair.refreshrate then
            last_render = _tick

            local position =
                (crosshair.mode == "center" and camera.ViewportSize / 2 or
                crosshair.mode == "mouse" and inputservice:GetMouseLocation() or
                crosshair.position)

            local text_1 = drawings.text[1]
            local text_2 = drawings.text[2]

            text_1.Visible = crosshair.enabled
            text_2.Visible = crosshair.enabled

            if crosshair.enabled then
                local text_x = text_1.TextBounds.X + text_2.TextBounds.X

                text_1.Position =
                    position +
                    Vector2.new(
                        -text_x / 2,
                        crosshair.radius + (crosshair.resize and crosshair.resize_max or crosshair.length) + 15
                    )
                text_2.Position = text_1.Position + Vector2.new(text_1.TextBounds.X)
                text_2.Color = crosshair.color

                for idx = 1, 4 do
                    local outline = drawings.crosshair[idx]
                    local inline = drawings.crosshair[idx + 4]

                    local angle = (idx - 1) * 90
                    local length = crosshair.length

                    if crosshair.spin then
                        local spin_angle = -_tick * crosshair.spin_speed % crosshair.spin_max
                        angle =
                            angle +
                            tweenservice:GetValue(spin_angle / 360, crosshair.spin_style, Enum.EasingDirection.InOut) *
                                360
                    end

                    if crosshair.resize then
                        local resize_length = tick() * crosshair.resize_speed % 180
                        length = crosshair.resize_min + math.sin(math.rad(resize_length)) * crosshair.resize_max
                    end

                    inline.Visible = true
                    inline.Color = crosshair.color
                    inline.From = position + solve(angle, crosshair.radius)
                    inline.To = position + solve(angle, crosshair.radius + length)
                    inline.Thickness = crosshair.width

                    outline.Visible = true
                    outline.From = position + solve(angle, crosshair.radius - 1)
                    outline.To = position + solve(angle, crosshair.radius + length + 1)
                    outline.Thickness = crosshair.width + 1.5
                end
            else
                for idx = 1, 4 do
                    drawings.crosshair[idx].Visible = false
                    drawings.crosshair[idx + 4].Visible = false
                end
            end
        end
    end
)

local player = game:GetService("Players").LocalPlayer
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local camera = Workspace.CurrentCamera

local lastTrigger = 0

local function isOtherPlayer(part)
    local model = part:FindFirstAncestorOfClass("Model")
    if not model or model == player.Character then return false end

    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end

    local bodyEffects = model:FindFirstChild("BodyEffects")
    local isKnocked = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
    local isGrabbed = model:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
    if isKnocked or isGrabbed then return false end

    if model:FindFirstChildOfClass("ForceField") then return false end

    return Players:GetPlayerFromCharacter(model) ~= nil
end

local function isToolAllowed()
    local character = player.Character
    local backpack = player:FindFirstChildOfClass("Backpack")
    if not character or not backpack then return false end

    for _, item in ipairs(character:GetChildren()) do
        if item:IsA("Tool") and getgenv().triggerbot.BlacklistedTools[item.Name] then
            return false
        end
    end

    for _, item in ipairs(backpack:GetChildren()) do
        if item:IsA("Tool") and getgenv().triggerbot.BlacklistedTools[item.Name] then
            return false
        end
    end

    return true
end

RunService.RenderStepped:Connect(function()
    if not getgenv().triggerbot.Enabled then return end

    local character = player.Character
    if not character or not isToolAllowed() then return end

    local now = tick()
    if now - lastTrigger < getgenv().triggerbot.TriggerCooldown then return end

    local origin = camera.CFrame.Position
    local direction = camera.CFrame.LookVector * 1000

    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local result = Workspace:Raycast(origin, direction, raycastParams)

    if result and result.Instance and isOtherPlayer(result.Instance) then
        lastTrigger = now
        print("Triggerbot Fired!")

        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA("Tool") then
                tool:Activate()
            end
        end
    end
end)

setup_hooks()

-- SETTINGS TAB UI
local SettingsTab = Tabs.Settings

-- Apply theme manager UI
thememanager:SetLibrary(library)
thememanager:SetFolder("Elysian")
thememanager:ApplyToTab(SettingsTab)

-- Apply save manager UI
savemanager:SetLibrary(library)
savemanager:SetFolder("Elysian/configs")
savemanager:SetIgnoreIndexes({"MenuKeybind"})
savemanager:BuildConfigSection(SettingsTab)

-- Auto-load last config
savemanager:LoadAutoloadConfig()

game.StarterGui:SetCore("SendNotification", {
    Title = "Eclipse",
    Text = "Eclipse successfully loaded",
    Duration = 3
})

task.spawn(function()
    while task.wait() do
        if getgenv().stile.hitbox_expander.Enabled then
            for _, player in pairs(game.Players:GetPlayers()) do
                if player ~= game.Players.LocalPlayer and player.Character then
                    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        pcall(function()
                            local size = getgenv().stile.hitbox_expander.Size
                            hrp.Size = Vector3.new(size, size, size)
                            hrp.Transparency = 1
                            hrp.Color = Color3.new(1,1,1)
                            hrp.Material = Enum.Material.SmoothPlastic
                            hrp.CanCollide = false
                        end)
                    end
                end
            end
        end
    end
end)

local function applySelfChams(char)
    if not getgenv().stile.Visuals.Self.Enabled then return end

    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Material = Enum.Material.Neon
            part.Color = getgenv().stile.Visuals.Self.Color
            part.CanCollide = false
        end
    end
end

local lp = game.Players.LocalPlayer

lp.CharacterAdded:Connect(function(char)
    task.wait(0.5)
    applySelfChams(char)
end)

if lp.Character then
    applySelfChams(lp.Character)
end

local default = {
    ["2dbox"] = { color = Color3.fromRGB(255, 255, 255), enable = true },
    ["name"] = { enable = true, placement = "Top" },
    ["studs"] = { enable = true },
    ["tool"] = { enable = true, placement = "Bottom" },
    ["fov"] = { enable = true },
    ["flags"] = { enable = true, placement = "Right" },
    ["skeleton"] = { enable = true, color = Color3.new(1, 1, 1), outlineEnabled = true, outlineColor = Color3.new(0, 0, 0), lineThickness = 1, outlineThickness = 3 },
    ["trail"] = { enable = true, rgb = Color3.fromRGB(255, 255, 255), thickness = 1 },
    ["highlight"] = { enable = true, fillColor = Color3.fromRGB(128, 128, 128), outlineColor = Color3.fromRGB(0, 0, 0), fillTransparency = 0.5, outlineTransparency = 0 }
}

local ps = game:GetService("Players")
local lp = ps.LocalPlayer
local rs = game:GetService("RunService")
local c = workspace.CurrentCamera
local userInputService = game:GetService("UserInputService")
local guiService = game:GetService("GuiService")

local worldToViewportPoint = c.WorldToViewportPoint
local HeadOff = Vector3.new(0, 0.5, 0)
local LegOff = Vector3.new(0, 3, 0)
local boxScaleFactor = 1.2
local boxCache = {}
local flagsCache = {}
local stackingInfo = {}
local playerESP = {}

local function getdistancefc(part)
    return (part.Position - c.CFrame.Position).Magnitude
end

local function getMovementState(humanoid, hrp)
    local velocity = hrp.Velocity
    if velocity.Y > 1 then
        return "jumping"
    end
    if velocity.Y < -1 then
        return "falling"
    end
    local horizontalSpeed = math.sqrt(velocity.X^2 + velocity.Z^2)
    if horizontalSpeed < 0.5 then
        return "idling"
    elseif horizontalSpeed <= 15 then
        return "walking"
    else
        return "running"
    end
end

local function getPosition(placement, boxPos, boxSize, userId, elementType)
    if not stackingInfo[userId] then
        stackingInfo[userId] = {
            Top = { count = 0, elements = {} },
            Bottom = { count = 0, elements = {} },
            Left = { count = 0, elements = {} },
            Right = { count = 0, elements = {} }
        }
    end
    if not stackingInfo[userId][placement].elements[elementType] then
        stackingInfo[userId][placement].count = stackingInfo[userId][placement].count + 1
        stackingInfo[userId][placement].elements[elementType] = stackingInfo[userId][placement].count
    end
    local stackPosition = stackingInfo[userId][placement].elements[elementType]
    local stackOffset = (stackPosition - 1) * 15
    if placement == "Top" then
        return Vector2.new(boxPos.X + boxSize.X/2, boxPos.Y - 20 - stackOffset), true
    elseif placement == "Bottom" then
        return Vector2.new(boxPos.X + boxSize.X/2, boxPos.Y + boxSize.Y + 10 + stackOffset), true
    elseif placement == "Left" then
        return Vector2.new(boxPos.X - 10, boxPos.Y + boxSize.Y/2 + stackOffset), false
    elseif placement == "Right" then
        return Vector2.new(boxPos.X + boxSize.X + 10, boxPos.Y + boxSize.Y/2 + stackOffset), false
    else
        return Vector2.new(boxPos.X + boxSize.X/2, boxPos.Y - 20), true
    end
end

local function resetStackingInfo(userId)
    stackingInfo[userId] = nil
end

local function esp(p, cr)
    local h = cr:WaitForChild("Humanoid")
    local head = cr:WaitForChild("Head")
    local text = Drawing.new("Text")
    text.Visible = false
    text.Outline = true 
    text.Font = 2
    text.Color = Color3.fromRGB(255,255,255)
    text.Size = 13
    local c1, c2, c3
    local function dc()
        text.Visible = false
        text:Remove()
        resetStackingInfo(p.UserId)
        if c1 then c1:Disconnect() end
        if c2 then c2:Disconnect() end
        if c3 then c3:Disconnect() end
    end
    c2 = cr.AncestryChanged:Connect(function(_, parent)
        if not parent then dc() end
    end)
    c3 = h.HealthChanged:Connect(function(v)
        if v <= 0 or h:GetState() == Enum.HumanoidStateType.Dead then dc() end
    end)
    c1 = rs.RenderStepped:Connect(function()
        if not boxCache[p.UserId] then return end
        local boxPos = boxCache[p.UserId].Box.Position
        local boxSize = boxCache[p.UserId].Box.Size
        if boxCache[p.UserId].Box.Visible then
            local pos, centered = getPosition(default.name.placement, boxPos, boxSize, p.UserId, "name")
            text.Position = pos
            text.Center = centered
            text.Text = p.Name .. ' (' .. tostring(math.floor(getdistancefc(head))) .. ' studs)'
            text.Visible = default.studs.enable
        else
            text.Visible = false
        end
    end)
end

local function flagsEsp(p, cr)
    local h = cr:WaitForChild("Humanoid")
    local hrp = cr:WaitForChild("HumanoidRootPart")
    local text = Drawing.new("Text")
    text.Visible = false
    text.Outline = true 
    text.Font = 2
    text.Color = Color3.fromRGB(255,255,255)
    text.Size = 13
    flagsCache[p.UserId] = text
    local c1, c2, c3
    local function dc()
        text.Visible = false
        text:Remove()
        flagsCache[p.UserId] = nil
        if c1 then c1:Disconnect() end
        if c2 then c2:Disconnect() end
        if c3 then c3:Disconnect() end
    end
    c2 = cr.AncestryChanged:Connect(function(_, parent)
        if not parent then dc() end
    end)
    c3 = h.HealthChanged:Connect(function(v)
        if v <= 0 or h:GetState() == Enum.HumanoidStateType.Dead then dc() end
    end)
    c1 = rs.RenderStepped:Connect(function()
        if not boxCache[p.UserId] then return end
        local boxPos = boxCache[p.UserId].Box.Position
        local boxSize = boxCache[p.UserId].Box.Size
        if boxCache[p.UserId].Box.Visible then
            local movementState = getMovementState(h, hrp)
            local pos, centered = getPosition(default.flags.placement, boxPos, boxSize, p.UserId, "flags")
            text.Position = pos
            text.Center = centered
            text.Text = "[" .. movementState .. "]"
            text.Visible = default.flags.enable
        else
            text.Visible = false
        end
    end)
end

local function updateBoxESP(v)
    if not boxCache[v.UserId] then
        boxCache[v.UserId] = {
            BoxOutline = Drawing.new("Square"),
            Box = Drawing.new("Square")
        }
        local BoxOutline = boxCache[v.UserId].BoxOutline
        BoxOutline.Visible = false
        BoxOutline.Color = Color3.new(0, 0, 0)
        BoxOutline.Thickness = 3
        BoxOutline.Transparency = 1
        BoxOutline.Filled = false
        local Box = boxCache[v.UserId].Box
        Box.Visible = false
        Box.Color = default["2dbox"].color
        Box.Thickness = 1
        Box.Transparency = 1
        Box.Filled = false
    end
    
    local connection
    connection = rs.RenderStepped:Connect(function()
        if not v or not v.Character or 
           not v.Character:FindFirstChild("Humanoid") or 
           not v.Character:FindFirstChild("HumanoidRootPart") or 
           v.Character.Humanoid.Health <= 0 then
            if boxCache[v.UserId] then
                boxCache[v.UserId].BoxOutline.Visible = false
                boxCache[v.UserId].Box.Visible = false
            end
            if connection then
                connection:Disconnect()
            end
            return
        end
        
        local hrp = v.Character.HumanoidRootPart
        local head = v.Character:FindFirstChild("Head")
        if head then
            local headPos, headOnScreen = c:WorldToViewportPoint(head.Position + HeadOff)
            local footPos, footOnScreen = c:WorldToViewportPoint(hrp.Position - LegOff)
            local hrpPos, onScreen = c:WorldToViewportPoint(hrp.Position)
            if headOnScreen and footOnScreen and onScreen then
                local scaleFactor = 1000 / hrpPos.Z
                local width = hrp.Size.X * scaleFactor * boxScaleFactor * 1.1 * 1.2  
                local height = (headPos.Y - footPos.Y) * 1.1
                local centerX = hrpPos.X
                local centerY = (headPos.Y + footPos.Y) / 2
                local BoxOutline = boxCache[v.UserId].BoxOutline
                local Box = boxCache[v.UserId].Box
                BoxOutline.Size = Vector2.new(width, height)
                BoxOutline.Position = Vector2.new(centerX - width / 2, centerY - height / 2)
                BoxOutline.Visible = default["2dbox"].enable
                Box.Size = Vector2.new(width, height)
                Box.Position = Vector2.new(centerX - width / 2, centerY - height / 2)
                Box.Visible = default["2dbox"].enable
                Box.Color = default["2dbox"].color
            else
                boxCache[v.UserId].BoxOutline.Visible = false
                boxCache[v.UserId].Box.Visible = false
            end
        end
    end)
end

local function ftool(cr)
    for _, b in next, cr:GetChildren() do 
        if b.ClassName == 'Tool' then return tostring(b.Name) end
    end
    return 'empty'
end

local function toolEsp(p, cr)
    local h = cr:WaitForChild("Humanoid")
    local hrp = cr:WaitForChild("HumanoidRootPart")
    local text = Drawing.new('Text')
    text.Visible = false
    text.Outline = true
    text.Color = Color3.new(1, 1, 1)
    text.Font = 2
    text.Size = 13
    local c1, c2, c3
    local function dc()
        text.Visible = false
        text:Remove()
        if c1 then c1:Disconnect() end
        if c2 then c2:Disconnect() end
        if c3 then c3:Disconnect() end
    end
    c2 = cr.AncestryChanged:Connect(function(_, parent)
        if not parent then dc() end
    end)
    c3 = h.HealthChanged:Connect(function(v)
        if v <= 0 or h:GetState() == Enum.HumanoidStateType.Dead then dc() end
    end)
    c1 = rs.Heartbeat:Connect(function()
        if not boxCache[p.UserId] then return end
        local boxPos = boxCache[p.UserId].Box.Position
        local boxSize = boxCache[p.UserId].Box.Size
        if boxCache[p.UserId].Box.Visible then
            local pos, centered = getPosition(default.tool.placement, boxPos, boxSize, p.UserId, "tool")
            text.Position = pos
            text.Center = centered
            text.Text = '[ ' .. tostring(ftool(cr)) .. ' ]'
            text.Visible = default.tool.enable
        else
            text.Visible = false
        end
    end)
end

local function createTrail(character)
    if not default.trail.enable then return end
    
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
    if not humanoidRootPart then return end
    
    local attachment0 = Instance.new("Attachment")
    attachment0.Position = Vector3.new(0, 0, 0)
    attachment0.Name = "TrailAttachment0"
    attachment0.Parent = humanoidRootPart
    
    local attachment1 = Instance.new("Attachment")
    attachment1.Position = Vector3.new(0, 0, -0.5)
    attachment1.Name = "TrailAttachment1"
    attachment1.Parent = humanoidRootPart
    
    local trail = Instance.new("Trail")
    trail.Attachment0 = attachment0
    trail.Attachment1 = attachment1
    trail.WidthScale = NumberSequence.new(default.trail.thickness)
    trail.Color = ColorSequence.new(default.trail.rgb)
    trail.Parent = humanoidRootPart
    
    return trail
end

local function createHighlight(player)
    if not playerESP[player] then
        playerESP[player] = {}
    end
    
    local highlight = Instance.new("Highlight")
    highlight.FillColor = default.highlight.fillColor
    highlight.OutlineColor = default.highlight.outlineColor
    highlight.FillTransparency = default.highlight.fillTransparency
    highlight.OutlineTransparency = default.highlight.outlineTransparency
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Enabled = default.highlight.enable
    
    playerESP[player].Highlight = highlight
    return highlight
end

local function updateHighlightESP(player)
    if not playerESP[player] or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local character = player.Character
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    
    if not humanoidRootPart or not humanoid then
        return
    end

    if playerESP[player].Highlight then
        if not playerESP[player].Highlight.Parent then
            playerESP[player].Highlight.Parent = character
        end
        
        playerESP[player].Highlight.Enabled = default.highlight.enable
        playerESP[player].Highlight.FillColor = default.highlight.fillColor
        playerESP[player].Highlight.OutlineColor = default.highlight.outlineColor
        playerESP[player].Highlight.FillTransparency = default.highlight.fillTransparency
        playerESP[player].Highlight.OutlineTransparency = default.highlight.outlineTransparency
    end
end

local R6_CONNECTIONS = {
    {'Head', 'Torso'},
    {'Torso', 'Left Arm'},
    {'Torso', 'Right Arm'},
    {'Torso', 'Left Leg'},
    {'Torso', 'Right Leg'}
}

local R15_CONNECTIONS = {
    {'Head', 'UpperTorso'},
    {'UpperTorso', 'LowerTorso'},
    {'UpperTorso', 'LeftUpperArm'},
    {'UpperTorso', 'RightUpperArm'},
    {'LeftUpperArm', 'LeftLowerArm'},
    {'LeftLowerArm', 'LeftHand'},
    {'RightUpperArm', 'RightLowerArm'},
    {'RightLowerArm', 'RightHand'},
    {'LowerTorso', 'LeftUpperLeg'},
    {'LowerTorso', 'RightUpperLeg'},
    {'LeftUpperLeg', 'LeftLowerLeg'},
    {'LeftLowerLeg', 'LeftFoot'},
    {'RightUpperLeg', 'RightLowerLeg'},
    {'RightLowerLeg', 'RightFoot'}
}

local lines = {}
local outlines = {}

local function worldToScreen(part)
    local position, onScreen = c:WorldToViewportPoint(part.Position)
    return Vector2.new(position.X, position.Y), onScreen
end

local function getCharacterRig(character)
    return character:FindFirstChild('Torso') and 'R6' or 'R15'
end

local function clearLines()
    for _, line in ipairs(lines) do
        line:Remove()
    end
    for _, outline in ipairs(outlines) do
        outline:Remove()
    end
    lines = {}
    outlines = {}
end

local function drawSkeleton()
    clearLines()
    
    if not default.skeleton.enable then return end
    
    for _, player in ipairs(ps:GetPlayers()) do
        if player ~= lp then
            local character = player.Character
            
            if character then
                local humanoid = character:FindFirstChild('Humanoid')
                local rootPart = character:FindFirstChild('HumanoidRootPart')
                
                if humanoid and rootPart and humanoid.Health > 0 then
                    local connections = getCharacterRig(character) == 'R6' and R6_CONNECTIONS or R15_CONNECTIONS
                    
                    for _, connection in ipairs(connections) do
                        local fromPart = character:FindFirstChild(connection[1])
                        local toPart = character:FindFirstChild(connection[2])
                        
                        if fromPart and toPart then
                            local fromScreen, fromVisible = worldToScreen(fromPart)
                            local toScreen, toVisible = worldToScreen(toPart)
                            
                            if fromVisible and toVisible then
                                if default.skeleton.outlineEnabled then
                                    local outline = Drawing.new('Line')
                                    outline.From = fromScreen
                                    outline.To = toScreen
                                    outline.Color = default.skeleton.outlineColor
                                    outline.Thickness = default.skeleton.outlineThickness
                                    outline.Visible = true
                                    table.insert(outlines, outline)
                                end
                                
                                local line = Drawing.new('Line')
                                line.From = fromScreen
                                line.To = toScreen
                                line.Color = default.skeleton.color
                                line.Thickness = default.skeleton.lineThickness
                                line.Visible = true
                                table.insert(lines, line)
                            end
                        end
                    end
                end
            end
        end
    end
end

local function playerRemoved(player)
    if playerESP[player] then
        if playerESP[player].Highlight then
            playerESP[player].Highlight:Destroy()
        end
        playerESP[player] = nil
    end
end

local function playerAdded(p)
    if p == lp then return end
    
    if not playerESP[p] then
        playerESP[p] = {}
        local highlight = createHighlight(p)
        
        local function characterAdded(cr)
            if highlight and cr then
                highlight.Parent = cr
                highlight.Enabled = default.highlight.enable
                
                esp(p, cr)
                toolEsp(p, cr)
                updateBoxESP(p)
                if default.flags.enable then
                    flagsEsp(p, cr)
                end
                if default.trail.enable then
                    createTrail(cr)
                end
            end
        end
        
        if p.Character then
            characterAdded(p.Character)
        end
        
        p.CharacterAdded:Connect(characterAdded)
    end
end

if default.fov.enable then
    local sides, radius = 18, 160
    local out_line, in_line = {}, {}
    for i = 1, sides do
        local o = Drawing.new("Line")
        o.Thickness, o.Color, o.Transparency = 3, Color3.new(), 1
        out_line[i] = o
        local l = Drawing.new("Line")
        l.Thickness, l.Color, l.Transparency = 1, Color3.new(1, 1, 1), 1
        in_line[i] = l
    end
    rs.RenderStepped:Connect(function()
        local center = (userInputService:GetMouseLocation() + guiService:GetGuiInset() - Vector2.new(0, 58))
        for i = 1, sides do
            local a1, a2 = math.rad(360 / sides * (i - 1)), math.rad(360 / sides * (i % sides))
            out_line[i].From = center + Vector2.new(math.cos(a1), math.sin(a1)) * radius
            out_line[i].To = center + Vector2.new(math.cos(a2), math.sin(a2)) * radius
            out_line[i].Visible = default.fov.enable
            in_line[i].From = center + Vector2.new(math.cos(a1), math.sin(a1)) * radius
            in_line[i].To = center + Vector2.new(math.cos(a2), math.sin(a2)) * radius
            in_line[i].Visible = default.fov.enable
        end
    end)
end

local watermark = Drawing.new("Text")
watermark.Text = "Rift.LoL"
watermark.Size = 16
watermark.Font = 2
watermark.Center = true
watermark.Outline = true
watermark.Color = Color3.new(1, 1, 1)
watermark.Visible = true
rs.RenderStepped:Connect(function()
    local mouse = userInputService:GetMouseLocation()
    watermark.Position = Vector2.new(mouse.X, mouse.Y + 20)
end)

for _, p in next, ps:GetPlayers() do
    if p ~= lp then
        playerAdded(p)
    end
end

ps.PlayerAdded:Connect(playerAdded)
ps.PlayerRemoving:Connect(playerRemoved)
rs.RenderStepped:Connect(drawSkeleton)
rs.RenderStepped:Connect(function()
    for player, _ in pairs(playerESP) do
        if player and player.Character then
            updateHighlightESP(player)
        end
    end
end)

return {
    SetBoxColor = function(color)
        default["2dbox"].color = color
    end,
    SetBoxEnabled = function(bool)
        default["2dbox"].enable = bool
    end,
    
    SetNameEnabled = function(bool)
        default.name.enable = bool
    end,
    SetNamePlacement = function(placement)
        default.name.placement = placement
    end,
    
    SetToolEnabled = function(bool)
        default.tool.enable = bool
    end,
    SetToolPlacement = function(placement)
        default.tool.placement = placement
    end,
    
    SetFlagsEnabled = function(bool)
        default.flags.enable = bool
    end,
    SetFlagsPlacement = function(placement)
        default.flags.placement = placement
    end,
    
    SetFOVEnabled = function(bool)
        default.fov.enable = bool
    end,
    
    SetSkeletonEnabled = function(bool) 
        default.skeleton.enable = bool 
    end,
    SetSkeletonColor = function(color) 
        default.skeleton.color = color 
    end,
    SetSkeletonOutlineColor = function(color) 
        default.skeleton.outlineColor = color 
    end,
    SetSkeletonLineThickness = function(thickness) 
        default.skeleton.lineThickness = thickness 
    end,
    SetSkeletonOutlineThickness = function(thickness) 
        default.skeleton.outlineThickness = thickness 
    end,
    SetSkeletonOutlineEnabled = function(bool) 
        default.skeleton.outlineEnabled = bool 
    end,
    
    SetTrailEnabled = function(bool)
        default.trail.enable = bool
    end,
    SetTrailColor = function(color)
        default.trail.rgb = color
    end,
    SetTrailThickness = function(thickness)
        default.trail.thickness = thickness
    end,
    
    SetHighlightEnabled = function(bool)
        default.highlight.enable = bool
    end,
    SetHighlightColor = function(color)
        default.highlight.fillColor = color
    end,
    SetHighlightOutlineColor = function(color)
        default.highlight.outlineColor = color
    end,
    SetHighlightFillTransparency = function(transparency)
        default.highlight.fillTransparency = transparency
    end,
    SetHighlightOutlineTransparency = function(transparency)
        default.highlight.outlineTransparency = transparency
    end,

    SetESPEnabled = function(bool)
        for setting, value in pairs(default) do
            if type(value) == "table" and value.enable ~= nil then
                value.enable = bool
            end
        end
    end
}
